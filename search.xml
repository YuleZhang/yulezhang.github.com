<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>腾讯字节实习面试总结</title>
    <url>/2021/09/03/69InternSummary/</url>
    <content><![CDATA[<p>近期想找一份关于后台开发的实习，全力准备了一个半月的算法，当前此前也有零碎的刷题。然后就直接投简历了，收到腾讯和字节两家面试通知，面试问题如下。</p>
<h3 id="腾讯">腾讯</h3>
<p>腾讯面经，部门主要是做AI算法的呈现</p>
<a id="more"></a>
<ul>
<li>自我介绍</li>
<li>TCP三次握手过程</li>
<li>数据库的索引机制</li>
<li>对redis，docker的了解</li>
<li>对虚拟化的了解</li>
<li>了不了解Go</li>
<li>Git rebase ，get statch的作用</li>
<li>算法：n方阵 <strong>马字走法</strong> 走到右下角的路径</li>
</ul>
<h3 id="字节">字节</h3>
<p>字节商业化部门面经</p>
<ul>
<li>https协议双方建立认证的过程</li>
<li>https传送数据是对称的还是非对称的</li>
<li>TCP为什么是四次挥手，单工通信下的TCP连接断开需要多少次</li>
<li>广告位兜售为何取竞价第二大的作为广告费，（达到纳什均衡）</li>
<li>常用的网络状态查看命令</li>
<li>DNS解析过程</li>
<li>ping命令的协议，traceroot如何做到路由追踪（自己挖的坑┭┮﹏┭┮）</li>
<li>C++指针和引用的区别</li>
<li>#define和const的区别</li>
<li>C++ 11中的auto关键字的作用，如何识别类型</li>
<li>写一个define求两数最大值</li>
<li>A，B两人抛硬币，谁正面朝上谁赢，问A赢得概率是多少</li>
<li>算法题：O(n)找数组中最大的三数乘积（数字之间互相不重复），记录三个最大值和两个最小的负数比较一下就可以。面试官提示我半天，我还是写了个动态规划解法</li>
</ul>
<p>反问：</p>
<p>1.部门后台开发工作介绍</p>
<p>2.部门采用的开发语言：Golang/C++</p>
<p>3.面试有几轮，答：三轮</p>
<p>在这面试后发现自己很多基础比较薄弱，理论性的知识准备的不够充分，对于git, redis, docker等目前比较主流的技术了解太浅。平时在校完全没有注意到这些，发现go语言已经不知不觉的普遍使用了。尽管面试结果一直没有通知（估计是挂了），但也让我不再局限于当前知道的那些东西，也算“<strong>更新</strong>”了我前进的方向吧。我已经做好了下一次冲击的准备。加油吧，战友们！</p>
]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣排列组合问题梳理（超详细）</title>
    <url>/2021/09/02/68CombinationLeetcode/</url>
    <content><![CDATA[<blockquote>
<p>说明：本文基于慕课《<a href="https://coding.imooc.com/class/82.html">玩转算法面试 从真题到思维全面提升算法思维</a>》，并加入了一些自己的理解。</p>
</blockquote>
<h2 id="递归与回溯框架">递归与回溯框架</h2>
<p>对于递归本身，可以结合二叉树的性质去理解，不是本文讨论的重点。本文讨论了更一般的递归问题和回溯的算法思想，这些问题在本质上也属于树形问题。顾名思义，对于问题解的讨论可以用一颗树来进行表示。来看一些例题</p>
<a id="more"></a>
<p><strong><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></strong></p>
<blockquote>
<p>给出一个数字字符串，返回这个数字字符串能表示的所有字母组合</p>
</blockquote>
<p>在梳理算法思路时还要确定以下情况的处理：</p>
<ul>
<li>字符串的合法性</li>
<li>空字符串</li>
<li>多个解的顺序</li>
</ul>
<p>这是一个典型的树形问题，例如对于字符串”23“而言，字符&quot;2&quot;能表示字符&quot;a&quot;, “b”, “c”。字符&quot;3&quot;能表示&quot;d&quot;,“e”,“f”。</p>
<img src='/assets/image-20210903085804118.png' width='40%'>
<p>那么就能构建出图中所示的一棵树，用digits表示数字字符串，s(digits)是digits所能代表的字母字符串，则</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>s</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>l</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>s</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>l</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp;s(digits[0, ..., n-1])\\
&amp;=letter(digits[0]) + s(digits[1, ..., n-1])\\
&amp;=letter(digits[0]) + letter(digits[1]) + s[digits[2, ..., n-1]]
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.4999999999999991em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>在上述公式中，求解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(digits[0,...,n-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>需要递归调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(digits[1,...,n-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，以此类推。代码如下</p>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; dict;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> depth, <span class="built_in">string</span> &amp;curStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.push_back(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:dict[digits[depth]])&#123;</span><br><span class="line">            curStr[depth] = ch;</span><br><span class="line">            dfs(digits, depth+<span class="number">1</span>, curStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(n, <span class="string">&#x27;#&#x27;</span>)</span></span>;</span><br><span class="line">        dict[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        dict[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p>回溯法是暴力解法的一个主要实现手段</p>
<p><strong><a href="https://leetcode.com/problems/restore-ip-addresses/">Restore IP Addresses</a></strong></p>
<p>给一个数字字符串，为这个数字子字符串加上三个点，使其成为一个合法的ip地址，返回所有的合法ip地址</p>
<ul>
<li>如给定字符串&quot;25525511135&quot;</li>
<li>返回{“255.255.11.135”, “255.255.111.35”}</li>
</ul>
<p><strong><a href="https://leetcode.com/problems/palindrome-partitioning/">Palindrome Partitioning</a></strong></p>
<p>给出一个字符串，拆分这个字符串，使得所有拆分的子串都是回文字符串，返回所有的拆分可能</p>
<ul>
<li>给定字符串s=“aab”</li>
<li>结果为[[“aa”, “b”], [“a”, “a”, “b”]]</li>
</ul>
<h2 id="排列问题">排列问题</h2>
<p><strong><a href="https://leetcode.com/problems/permutations/">Permutations</a></strong></p>
<p>给定一个整形数组，其中各个元素都不相同，返回这些元素所有排列的可能。全排列问题，其递归形式为</p>
<p><img src="/assets/image.png" alt="Image"></p>
<p>注意变量的恢复</p>
<p><strong><a href="https://leetcode.com/problems/permutations-ii/">Permutations II</a></strong></p>
<p>给定一个整型数组，其中可能有相同的元素，返回这些元素所有排列的可能</p>
<ul>
<li>如对于[1,1,2]</li>
<li>返回[[1,1,2],[1,2,1],[2,1,1]]</li>
</ul>
<h2 id="组合问题">组合问题</h2>
<p>给出两个整数n和k，求在1…n这n个数字中选出k个数字的所有组合</p>
<ul>
<li>如n=4, k = 2</li>
<li>结果为[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</li>
</ul>
<p>注意不能重复，因此每次从上一个数字之后开始取，但当n和k的规模大了以后就会比较吃力，采用<strong>回溯法的剪支</strong></p>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getComb</span><span class="params">(<span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth == k)&#123;</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前已经有tmp.size()个元素，还要在[1,n]中找出k-tmp.size()个</span></span><br><span class="line">    <span class="comment">// 则i最多为n - (k-c.size()) + 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= n - (k-c.<span class="built_in">size</span>()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">        tmp.push_back(i);</span><br><span class="line">        getComb(depth+<span class="number">1</span>, tmp, i);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    getComb(<span class="number">0</span>, tmp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p><strong>39. Combination Sum</strong></p>
<p>给出一个集合，其中所有的元素各不相同，以及一个数字T。寻找所有该集合中的元素组合，使得组合中的所有元素和为T。（注意集合中每一个元素可以使用多次）</p>
<ul>
<li>如给定集合nums=[2,3,6,7], T=7</li>
<li>返回[[7], [2,2,3]]</li>
<li>代码，排序加快搜索速度</li>
</ul>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; n &amp;&amp; target-arr[i]&gt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">        tmp.push_back(arr[i]);</span><br><span class="line">        dfs(arr, target-arr[i], tmp, i);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    n = candidates.size();</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    dfs(candidates, target, tmp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p><strong>40. Combination Sum II</strong></p>
<p>给出一个集合，其中元素可能相同，以及一个数字T。寻找所有该集合中的元素组合，使得组合中所有元素的和为T。（注意：集合中每一个元素只能用一次）</p>
<ul>
<li><strong>代码——巧妙地去重</strong></li>
</ul>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; arr.<span class="built_in">size</span>() &amp;&amp; target-arr[i] &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; arr[i] == arr[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> copy = arr[i];</span><br><span class="line">                arr[i] = <span class="number">0</span>;</span><br><span class="line">                tmp.push_back(copy);</span><br><span class="line">                dfs(arr, target-copy, tmp, i+<span class="number">1</span>);</span><br><span class="line">                arr[i] = copy;</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = candidates.<span class="built_in">size</span>();</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>()); <span class="comment">// 排个序，加快搜索效率</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(candidates, target, tmp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p><strong>216. Combination Sum III</strong></p>
<p>在1-9这九个数字中，选出k个数字，每个数字只能使用一次，使得其和为n</p>
<ul>
<li>如n=7, k = 3, 结果为【【1，2，4】】</li>
<li>代码</li>
</ul>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) ans.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(k<span class="number">-1</span>, n-i, i, tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    flag = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    dfs(k, n, <span class="number">1</span>, tmp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p><strong>377. Combination Sum IV</strong></p>
<p>给定一组不同的整数 nums 和一个目标整数目标，返回加起来为目标的可能组合数。 答案保证适合 32 位整数。</p>
<ul>
<li>如nums = [1,2,3], target = 4，结果为7</li>
</ul>
<div style="margin-top: -20px;"><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div><div class="fold">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() &amp;&amp; target-nums[i]&gt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        dfs(nums, target-nums[i], tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(nums, target, tmp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="fold_hider"><div class="close hider_title"><span style="color:gray;font-size:12px">点击查看代码</span></div></div></div>
<p>上面四个力扣的组合问题是递归问题中的典型代表，通过对这些题目的理解和细节对比能够轻而易举总结处一套模板出来。尽管在Combination Sum IV中这样的模板因超时而无法AC，但这并不影响我们对这一类问题的理解。仔细观察这些题目中<strong>细微的区别与解法的调整</strong>，这是模板定制的基本功。下面再次的进行梳理：</p>
<ol>
<li>对于数组中<strong>有重复元素</strong>，但每个只能使用一次（Combination Sum II）</li>
<li>数组数字各不相同，数字可以重复使用，结果可以重复（Combination Sum IV）</li>
<li>数组数字各不相同，数字可以重复使用，结果不可以重复（Combination Sum）</li>
<li>对于数字各不相同，且不能重复使用（Combination Sum III）</li>
</ol>
<p>从上面这四种条件中，我整理出以下的应对方案：</p>
<p>1.对于数组中有重复元素的情况，如果不加以区别，会造成重复的结果，举例来说[1,1,2,5,7]要凑成8。直接套用模板时难免出现结果中有两个[1,2,5],[1,7]的情况。这时候可以在循环中加入去重的语句，避免同一个数字重复的在一次搜索中两次作为起点，也就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; arr[i] == arr[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>2.对于结果可以重复的就是模板直接求出来的结果</p>
<p>3.对于不可以重复，可以在递归过程中引入index来标记上一次查的位置，让每次新的位置只能在上一次之后，就避免了结果重复的问题，见Combination Sum II。</p>
<p>组合问题是计算机中一类比较重要的问题，它的扩展问题可以是子集问题（No. 78, No. 90）,也可以是岛屿问题（<a href="https://leetcode.com/problems/number-of-islands/">No. 200</a>, <a href="https://leetcode.com/problems/number-of-islands-ii/">No. 305</a>, <a href="https://leetcode.com/problems/number-of-distinct-islands/">No. 694</a>）等等，尽管形式丰富，但主要是围绕递归和回溯来展开的，以点及面可以逐步解决此类问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>TGen-NU model fusion</title>
    <url>/2021/05/02/66CodeDetect/</url>
    <content><![CDATA[<p>本周工作</p>
<ul>
<li>TGAN生成X-ray图片</li>
<li>GenPU生成X-ray图片</li>
<li>设计<strong>TGen-NU</strong>模型，并尝试生成X-ray图片</li>
<li>解决归一化问题<sup>[1]</sup></li>
<li>基本完成TGen-NU的生成任务，但仍存在<strong>不稳定、不收敛</strong>问题<sup>[2]</sup></li>
<li>查阅学习GAN的公式推导、扩展资料如<strong>WGAN、DCGAN</strong>等</li>
<li>新思路：把MPS融入到GenPU/TGen-NU模型中</li>
</ul>
<a id="more"></a>
<p>4月29日 发现问题</p>
<p>【1】归一化问题及处理思路</p>
<p>直接原因：张量的初始化</p>
<p>预备知识：<strong>高斯白噪声</strong></p>
<p>所谓高斯白噪声(White Gaussian Noise)中的高斯是指<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/828907">概率分布</a>是正态函数，而<a href="https://baike.baidu.com/item/%E7%99%BD%E5%99%AA%E5%A3%B0/4062223">白噪声</a>是指它的二阶矩不相关，一阶矩为常数，是指先后信号在时间上的相关性。高斯白噪声是分析信道加性噪声的理想模型，通信中的主要噪声源——<a href="https://baike.baidu.com/item/%E7%83%AD%E5%99%AA%E5%A3%B0/10790461">热噪声</a>就属于这类噪声。在数学之美的网页作弊中，也提到有高斯白噪声。</p>
<p>下面步入正题，由于效果，我在GenPU模型中避开了高斯白噪声的初始化，而仅让它们满足取值在0-1之间。于是在pytorch中出现<strong>张量收缩的结果不在0-1之间的问题</strong>，就导致激活函数会将该结果激活到1或0附近，就会看到如下的空白格，无论迭代多少次都是这样，因为判别器失效了。</p>
<img src='/assets/image-20210429110035654.png' width="50%">
<p>但是采用pytorch中的Normalize方法又会固定的将判别器的输出变成1，因为映射成(batch, 1)的格式再按第二个维度归一化确实就是1，此外Normalize操作也会破坏学习到的概率分布（实验结论）。</p>
<p>那transform.Normalize()是怎么工作的呢？以上面代码为例，ToTensor()能够把灰度范围从0-255变换到0-1之间，而后面的transform.Normalize()则把0-1变换到(-1,1).具体地说，对每个通道而言，Normalize执行以下操作：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>−</mo><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>s</mi><mi>t</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">image=(image-mean)/std
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">d</span></span></span></span></span></p>
<p>其中mean和std分别通过(0.5,0.5,0.5)和(0.5,0.5,0.5)进行指定。原来的0-1最小值0则变成(0-0.5)/0.5=-1，而最大值1则变成(1-0.5)/0.5=1.</p>
<blockquote>
<p><a href="https://discuss.pytorch.org/t/understanding-transform-normalize/21730/21">Pytorch discuss</a></p>
<p>So if we encounter grayscale images, we will use</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;transforms.Normalize([0.5], [0.5])</span><br></pre></td></tr></table></figure>
<p>and if we encounter RGB( 3 channels ) , we will use the following</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;transforms.Normalize(mean&#x3D;[0.485, 0.456, 0.406],</span><br><span class="line">                    std&#x3D;[0.229, 0.224, 0.225]) </span><br></pre></td></tr></table></figure>
</blockquote>
<p>【2】不稳定、不收敛、模式崩溃问题</p>
<p>在实验过程中还经常遇到另一类问题，那就是<strong>负样本的生成模型</strong>总是无法学习到真实样本的概率分布。如下图所示，图左为迭代了2700次的<strong>负样本生成器 (n_gen)</strong>，图右为迭代了2700次的<strong>正样本生成器 (p_gen)</strong>。明显看到正样本生成器的生成效果还算不错，可是负样本没有学习到样本的概率分布，也就是出现了不收敛的情况。</p>
<img src='/assets/image-20210503155623663.png' width = '80%'>
<p>在网上查阅了相关资料，有学者层讨论并尝试改进<strong>GAN网络的训练不稳定不收敛问题</strong>，除此之外GAN网络还有模式崩溃问题。模式崩溃问题指的是GAN网络最终只需学到几个别的样本，并且跟样本完全一样，这类似于神经网络里常见的<strong>过拟合</strong>问题，目前还在进一步调试分析中。</p>
<p>【3】找bug思路</p>
<p>程序报错还是比较容易去解决的，最糟糕的就是费尽周折之后在网上找到某种解决方案，解决了程序也就能正常运行了。可有些错误是潜在的，程序不会运行中断，可你就是得不到理想的结果。这时就要学会去排查错误，排查错误的方式有很多种，最简单的也是最直接的就是<strong>在不影响整体的情况下注释掉一个个模块，逐步比较各个层的输入输出排查。</strong></p>
<p>在GAN网络中tensor layer不能学习到样本的概率分布，这也是一种很明显的错误。但自带的Linear是可以的，这就说明极有可能自己加的tensor layer中某个地方出现了问题，和Linear带来的输入和输出不一致。这时不能简单把某个模块注释掉，而是尝试从一个简单的模型开始算起，有一个可正确运行的version进行输入输出对比，最终找到normalize带来的问题。这也是一种重要的找问题思路，从简到繁。</p>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>实验复现</category>
      </categories>
  </entry>
  <entry>
    <title>量子机器学习资料整理</title>
    <url>/2021/03/28/62QML-Collections/</url>
    <content><![CDATA[<p>由于目前张量网络的工作逐渐增多，很多实验室都封装了自己的张量收缩算法包，同时还有一些论文给出了具体的工作，在此归类梳理一下方便日后的学习。</p>
<h2 id="workshop">Workshop</h2>
<ul>
<li><a href="https://tensorworkshop.github.io/2020/index.html"><strong>IJCAL</strong></a>: International Workshop on Tensor Network Representations in Machine Learning</li>
<li><a href="https://tensorworkshop.github.io/NeurIPS2020/"><strong>NeurIPS2020</strong></a>: Quantum tensor networks in machine learning</li>
<li><a href="http://ipam.ucla.edu/wp-content/uploads/2019/09/TMWS2-Poster.pdf">ipam</a>: Tensor Network States and Applications, <strong>APRIL 19 - 23, 2021</strong></li>
</ul>
<a id="more"></a>
<h2 id="learning-materials">Learning Materials</h2>
<ul>
<li><a href="https://github.com/ranshiju/TN_tutorial">TN_tutorial</a>是冉仕举老师对张量网络机器学习的一个详细的介绍，该仓库是<a href="https://www.bilibili.com/video/BV17z411i7yM?p=1">Bilibili视频</a>的配套代码，搭配食用效果更佳。</li>
<li><a href="https://www.tensors.net/"><strong>Tensors</strong>.net</a>是一个开源的网站，里面图解了各种张量网络算法，并给出了Python/Matlab/Julia的相关实现，简直良心</li>
<li><a href="https://paperswithcode.com/task/tensor-networks">Tensor Networks</a>提供了一些张量网络机器学习的视频、论文以及对应代码，也是做了于本仓库类似的内容，推荐大家结合代码去学习，事半功倍！</li>
<li><a href="https://github.com/krishnakumarsekar/awesome-quantum-machine-learning">awesome-quantum-machine-learning</a>包含了全网所有的量子机器学习基础知识，算法，研究材料，项目以及项目描述，例如<strong>量子遗传算法、量子隐马尔可夫模型、基于主成分分析的量子分类算法</strong>等等，有很多比较<strong>前沿的工作</strong>在里面。</li>
<li><a href="https://tensornetwork.org/">tensornetwork.org</a>张量网络算法、理论和软件的介绍</li>
</ul>
<h2 id="tensor-network-library"><strong>Tensor network library</strong></h2>
<p>大部分张量网络收缩库都是基于Python，还有少量的C++、Matlab，在下面会注明</p>
<ul>
<li><a href="https://github.com/google/TensorNetwork">TensorNetwork</a>，Google于2019年开源的Python库，目前应用最为广泛</li>
<li><a href="https://github.com/qmlcode/qml">qml</a>是用于量子机器学习的Python工具包，有回归、预测、学习曲线等等，能省很多功夫去造轮子</li>
<li><a href="https://github.com/dsuess/mpnum">mpnum</a>是基于Python的MPS包，还封装有MPO、PMPS、MPA的张量格式。</li>
<li><a href="https://github.com/netket/netket">netket</a>是一个开源代码项目，它提供了用于通过ANN和ML研究多体量子系统的前沿方法，它是基于JAX构建的Python库。</li>
<li><a href="https://github.com/tenpy/tenpy">tenpy</a> Python库，用于模拟具有张量网络的高度相关的量子系统，有比较详细的文档和算法演示示例（例如TEBD和DMRG）</li>
<li><a href="https://github.com/OriginQ/QPanda-2">PyQPanda</a>是<strong>本源量子</strong>开发的量子计算编程框架，提供了详细的文档和量子算法介绍，能够通过线路模拟算法。</li>
<li><a href="https://github.com/andrewdarmawan/tncontract">tncontract</a> Python的开源张量网络库，比较小众，采用Numpy库做为后端，包含很多用于一维和二维张量网络的算法。</li>
<li><a href="https://github.com/emstoudenmire/TNML">TNML(<strong>C++</strong>)</a>  出自大佬<a href="https://github.com/emstoudenmire/TNML/commits?author=emstoudenmire">emstoudenmire</a>之手</li>
<li><a href="https://github.com/ITensor/ITensor">ITensor(C++)</a> 高效的张量网络计算库，提供了相关文档</li>
</ul>
<h2 id="survery-with-code-updating">Survery with code（Updating…）</h2>
<ul>
<li><strong>Fully-Connected Tensor Network Decomposition and Its Application to Higher-Order Tensor Completion</strong> <a href="https://qibinzhao.github.io/publications/AAAI2021_Yu_Bang_Zheng/AAAI2021_FCTN_Decomposition_ybz.pdf">[Paper]</a> <a href="https://qibinzhao.github.io//publications/AAAI2021_Yu_Bang_Zheng/code_FCTN_Decomposition.zip">[Code]</a></li>
<li>Segmenting two-dimensional structures with strided tensor networks <a href="https://github.com/raghavian/strided-tenet">[Github]</a>
<ul>
<li>Raghavendra Selvan et al. (CVPR 2021)</li>
</ul>
</li>
<li>Generative tensor network classification model for supervised machine learning <a href="https://arxiv.org/abs/1903.10742">[arXiv]</a> <a href="https://github.com/crazybigcat/GTNC">[Github]</a>
<ul>
<li>Zheng-Zhi Sun, et al. (PRB 2020)</li>
</ul>
</li>
<li>Tangent-Space Gradient Optimization of Tensor Network for Machine Learning  <a href="https://arxiv.org/abs/2001.04029">[arXiv]</a> <a href="https://github.com/crazybigcat/TSGO">[Github]</a>
<ul>
<li>Zheng-Zhi Sun, et al. (PRE 2020)</li>
</ul>
</li>
<li>Multi-layered tensor networks for image classification <a href="https://arxiv.org/abs/2011.06982">[arXiv]</a> <a href="https://github.com/raghavian/mltn">[Github]</a>
<ul>
<li>Raghavendra Selvan et al. (NeurIPS 2020)</li>
</ul>
</li>
<li>Quantum Tensor Network in Machine Learning: An Application to Tiny Object Classification <a href="https://arxiv.org/pdf/2101.03154.pdf">[arXiv]</a> <a href="https://github.com/timqqt/MERA_Image_Classification">[Github]</a>
<ul>
<li>Fanjie Kong et al. (NeurIPS 2020)</li>
</ul>
</li>
<li>Tensor Networks for Medical Image Classification <a href="https://github.com/raghavian/loTeNet_pytorch/">[Github]</a>
<ul>
<li>Raghavendra Selvan et al. (MIDL 2020)</li>
</ul>
</li>
<li>Deep convolutional tensor network <a href="https://arxiv.org/abs/2005.14506">[arXiv]</a> <a href="https://github.com/philip-bl/dctn">[Github]</a>
<ul>
<li>Philip Blagoveschensky et al. (Preprint. Under review 2020)</li>
</ul>
</li>
<li>Quantum-Classical Machine learning by Hybrid Tensor Networks <a href="https://arxiv.org/abs/2005.09428">[arXiv]</a> <a href="https://github.com/dingliu0305/Hybrid-Tensor-Network">[Github]</a></li>
<li>Machine Learning by Two-Dimensional Hierarchical Tensor Networks: A Quantum Information Theoretic Perspective on Deep Architectures <a href="https://arxiv.org/abs/1710.04833">[arXiv]</a> <a href="https://github.com/dingliu0305/Tree-Tensor-Networks-in-Machine-Learning">[Github]</a>
<ul>
<li>Ding Liu et al. (NJP 2019)</li>
</ul>
</li>
<li>Unsupervised Generative Modeling Using Matrix Product States <a href="https://arxiv.org/abs/1709.01662">[arXiv]</a> <a href="https://github.com/congzlwag/UnsupGenModbyMPS">[Github]</a>
<ul>
<li>Zhao-Yu Han et al. (PRX 2018)</li>
</ul>
</li>
<li>Supervised Learning with Quantum-Inspired Tensor Networks <a href="https://github.com/emstoudenmire/TNML">[Github]</a>
<ul>
<li>E.M. Stoudenmire et al. (NIPS 2016)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>资料整理</category>
      </categories>
  </entry>
  <entry>
    <title>《智能时代》读书笔记</title>
    <url>/2021/03/27/60ReadBook/</url>
    <content><![CDATA[<p>总结了一下华为软挑比赛，同时整理了一下<a href="http://www.yulezhang.com/2021/03/28/62QML-Collections/">量子机器学习的代码学习资料</a>，并对二维MERA结构进行了数据集拓展、阅读《智能时代》。</p>
<a id="more"></a>
<h1>算法实践</h1>
<p>本周将假期学的<strong>Quantum Tensor Network in Machine Learning An Application to Tiny Object Classification</strong>这篇论文的代码又重新复习了一下，作者通过二维的张量网络结构进行小目标分类。而医学图像，尤其对新冠肺炎图像，它也属于这种小目标图像的范畴。因为该论文讨论的是二维的MERA结构，能够保留图片的局部信息，那么它的识别效果应该比单MPS架构要好很多，并且相比GTNC这里用到极少的环境变量，响应需要更新的参数也会少很多。因此这次实验主要从<strong>识别精度、参数量、运行时间</strong>三个角度进行评估。</p>
<p>在代码方面较之前增加了MERA的层数以应对更大的图片，同时增加了对新冠肺炎图片的处理和读取(loader模块)，修改了MPS的输入输出参数，使得MERA各个层之间传递的bond对应起来。关于实验结果，由于新馆肺炎图像比较大，处理起来比较慢，因此还没有得到完整的结果</p>
<h1>《智能时代》</h1>
<p>几个体现数据作用的例子</p>
<ol>
<li>托勒密小圆套大圆来求星星运动轨迹，这种想法影响了人类一千多年</li>
<li>日本的公司根据<strong>王进喜大庆油田的照片</strong>推断出一系列油田相关的信息，一举中标</li>
<li>盖洛普利用统计学+数据问卷收集民意，成功预测美国大选</li>
<li>IBM的语音识别基于数据的突破</li>
<li>量变到质变，Google机器翻译打败传统AI（手动编写语法逻辑）</li>
</ol>
<p>如果说数据的相关性我还知道一些的话（之前做过基于Apriori的关联分析），那么数据的完备性则是我平时一直忽略的点。数据的完备性指的是，你的样本要尽可能的涵盖大部分的情况或者对象。举个例子而言，比如预测大选的时候，调研不能只考虑精英那批人的意见，而要收集到各个阶层、不同收入、不同知识文化水平等人的完整意见，这样能够使得样本尽可能的完整，这方面的例子有Google机器翻译、斯维尔预测50+1州投票情况。</p>
<p>另外就是从托勒密到伽利略、再到牛顿、瓦特、莱特兄弟，他们都是基于机械思维，这种思维是改变了人类工作方式的革命性的方法论，并且在工业革命和全球工业化中起到了决定性的作用。但今天我们面临的复杂情况，已经不在能用几个定律就讲清楚了，难以找到确定性是现在社会的常态。<strong>而大数据科学基础是信息论，它的本质就是利用信息消除不确定性。大数据时代，量变带来质变，信息论的思维让过去很多问题迎刃而解</strong>。一个典型的例子就是Google和Microsoft搜索引擎之争，这完全是数据层面的竞争。尽管Microsoft的搜索算法同样先进，但他的Bing显然没有Google那么庞大的历史搜索记录，因此就很难去进一步提高结果推荐质量。可见数据的竞争，尤其是大数据对各行各业、各个领域都产生了革命性的作用。</p>
<p>将大数据的思维应用到<strong>医学图像领域</strong>的分析中来，要想用数据去遍布各个病例，那就要求医院能够提供大量的样本。而实际生活中，各个医院可能还没有在各种设备中有意识的收集数据，并且不同医院采用不同的管理系统，采用不同的设备处理信息，因此可能得到的数据会因设备参数而产生差异，再加上有些病例比较罕见。这种种原因意味着医学大数据还需要沉淀和积累，于是目前大家普遍采用的还是<strong>基于机械思维的图像分割算法</strong>，通过对医学图像的各种基于规则的分割，把图片的特征提取出来，然后再进行建模和预测。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>周汇报</category>
      </categories>
  </entry>
  <entry>
    <title>华为软件精英挑战赛</title>
    <url>/2021/03/27/61HuaweiSoftwareContest/</url>
    <content><![CDATA[<p>能够承认自己的普通并非易事</p>
<a id="more"></a>
<ul>
<li>初赛
<ul>
<li>[x] 03-10 9:00：公布初赛赛题，大赛网站开放赛题、赛题包下载</li>
<li>[x] 03-10 9:00 —— 03-24 18:00：初赛练习阶段</li>
<li>[x] 03-10 9:00：公布练习数据集，开启线上训练赛</li>
<li>[x] 03-24 18:00 —— 3月25日 9:00 ：关闭在线训练作品提交窗口</li>
<li>[x] 03-25 9:00 —— 03-27 18:00 ：初赛参赛作品提交阶段</li>
<li>[ ] 03-25 9:00：大赛网站更新正式赛数据集并恢复提交</li>
<li>[ ] 03-27 18:00：初赛截止提交</li>
<li>[ ] 03-27 18:00 —— 3月28日 12:00 系统评阅</li>
<li>[ ] 03-28 12:00：公示初赛获奖名单及成绩</li>
<li>[ ] 03-29 12:00：公布最终初赛获奖名单及成绩</li>
</ul>
</li>
</ul>
<p>到今天为止，为期两周的华为软挑比赛告一段落，我们队没能进入复赛，有些可惜，但很正常，毕竟大家都是第一次参加，而且平时科研任务也比较重。所以当我在18点之前拼命的提交最后一波结果的时候，我已经提前接受了，至少我不后悔。这次比赛确实给我上了一课。</p>
<p><strong>文档</strong></p>
<p>原本我认为Coding是最重要的，不要讨论那么多，先把写出来再说，最少得写一个Demo出来罢。以至于初期我一直反感于建辉一直整理文档，整来整去没有一点进度，还不如调几个bug想办法优化优化baseline。但随着后来的开发，我渐渐的发现有文档的好处。随着代码中变量和函数的增加，越来越难以记住各种各样的定义，有了文档能够随时的进行比对，知道哪个变量里面存什么字段、作用是什么，不仅方便自己，其他人看的时候也能统一来操作。这也就是为什么公司和企业一直都要写文档写手册，尽管自己看起来真的很繁琐很多余，但它发挥的作用确实是不可替代的。</p>
<p><strong>算法逻辑</strong></p>
<p>我一直以为算法它直接写就行，写着写着就明白了。可近些日子无论是写算法还是写<code>CodeCraft.cpp</code>程序，都能感觉到有些题目或者函数比较复杂，牵扯到的变量比较多，而且逻辑不容易梳理清楚，这个时候我就越写越乱，越写越头疼，写不下去，最后还是得笔画半天才能设计出来。通过小组讨论和沟通的过程，我体会到当我们从优化角度达成一致的时候，或者处理思路一致的时候效率是最高的，写代码真的就是个体力活了。以后要继续从事这方面的工作，还是要先思考再动手。否则会忽视很多细节问题，后期对开发造成阻碍。</p>
<p><strong>团队协作</strong></p>
<p>其实我和其他人，尤其是大家水平相差不大的同学合作写一个项目的机会并不多。在这次合作中，我确实感觉到了众人拾柴火焰高的感觉，每个人都能补充一些细节出来，让程序更加完善。由于我和建辉的关注点或者说是对程序的了解程度不一样，导致我俩总是很难通过qq几条消息达成一致，于是我体会到面对面沟通讨论带来的益处，并且这种不同视角也总是能够互相突破对方的难关。但不得不说，在整个比赛中，我们沟通的不是很充分。</p>
<p><strong>其他</strong></p>
<p>最后就是我要面临科研和比赛的平衡，我已经不是一次两次遇上这种需要平衡双方的问题了。但是我次次都做不好，因为沉迷这个总会忽略哪个，单线程的思维是我的优点也是我的缺点。平衡不好就会导致我的生活一团糟，因为两方面我都想兼顾，并且有时候还贪婪，如果发现没有以前做的好我就会bad mood，也许就是太浮躁罢。关于赛题本身（虚拟机分配服务器），涉及到博弈论的知识和算法，可能大家采用的都是贪心策略，可我们也许对这个思想理解的不是很到位，加上时间的原因，导致很多地方没有完善好，有些可惜了，再接再厉！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Grover</title>
    <url>/2021/03/14/58Grover/</url>
    <content><![CDATA[<p><strong>Grover算法</strong></p>
<p>搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。现阶段一般有枚举算法、深度优先搜索、广度优先搜索、A*算法、回溯算法、蒙特卡洛树搜索、散列函数等算法。比较常见的一种应用场景就是A到B的最短耗时路径搜索，一般的传统方法我们至少要把所有的路径遍历一遍来求解，而量子Grover算法只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mo stretchy="false">(</mo></msqrt><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mopen" style="padding-left:1em;">(</span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的复杂度就能解决该问题。</p>
<a id="more"></a>
<p><img src="/assets/%E5%9B%BE%E7%89%871.gif" alt="图片1"></p>
<p>具体而言，Grover算法是一种量子算法，于1996年由计算机科学家 Lov Grover提出。假设现在有一个未知的函数，Grover算法只需对此未知的函数做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mo stretchy="false">(</mo></msqrt><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mopen" style="padding-left:1em;">(</span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>次测试，就能求得满足未知函数方程的解。下面详细介绍Grover算法的过程，首先我们定义如下的求解问题</p>
<p>假定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">N=2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>(后面会知道为何这样设计)的搜索空间，有M个解，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的数(简化了搜索空间)，输入x对应的输出用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>定义为可能解集合，于是搜索问题可以表示为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="normal">Ω</mi><mo>⟶</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: \Omega \longrightarrow\{0,1\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord">Ω</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p>
<p>那么现在要找满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,假设被查找的集合为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mi>i</mi><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{|i\rangle\}=\{|0\rangle,|1\rangle, \cdots,|N-1\rangle\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mclose">⟩</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⟩</span><span class="mclose">}</span></span></span></span>，并且量子Orcale可以识别搜素问题的解，Orcale可定义为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">⟩</mo><mo><mover><mo><mo>⟶</mo></mo><mtext> Orade </mtext></mover></mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mi>q</mi><mo>⊕</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|x\rangle|q\rangle \stackrel{\text { Orade }}{\longrightarrow}|x\rangle|q \oplus f(x)\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5471080000000001em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2971080000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> Orade </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|q\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">⟩</span></span></span></span>是一个结果寄存器。通过Oracle, 当搜索的索引为目标结果时, 结果寄存器翻转；不是目标结果时, 结果寄存器不变。举个例子，例如当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|q\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">⟩</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|0\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，那么二者的&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊕</span></span></span></span>&quot;运算就是1，会存到结果寄存器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|q\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">⟩</span></span></span></span>中，相对于初始为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|0\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span></span></span></span>，它显然时发生了寄存器反转，因此我们通过Orcale得到了目标结果。反之当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，0和0的异或还是0，就没有发生反转，这就不是我们要求的解，同理当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|q\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">⟩</span></span></span></span>初始为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|1\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span></span></span></span>也一样。</p>
<p>因此简单来说, Oracle 的大致功能可以作如下定义</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>ω</mi></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>x</mi><mo mathvariant="normal">≠</mo><mi>ω</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>x</mi><mo>=</mo><mi>ω</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">O_{\omega}|x\rangle=\left\{\begin{array}{ll}
|x\rangle, &amp; \text { if } x \neq \omega \\
-|x\rangle, &amp; \text { if } x=\omega
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>配合两个寄存器, Oracle 对量子态的具体操作为：先将初态制备在态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><msup><mo>⊕</mo><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|0\rangle \oplus^{n}|1\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊕</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span></span></span></span>上。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><msup><mo>⊕</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">|0\rangle \oplus^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mord"><span class="mbin">⊕</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>为查询寄存器，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|1\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span></span></span></span>为结果寄存器。经过 H 门操作后, 可以将查询寄存器的<br>
量子态, 变为所有结果的叠加态, 即得到所有结果的索引, 且结果寄存器变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">H|1\rangle=(|0\rangle-|1\rangle) / \sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1572200000000001em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span><span class="mclose">)</span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>，再使其通过 Oracle, 可以对每一个索引进行检验， 若是目<br>
标结果, 则将结果寄存器的量子态进行 0、1 翻转，即</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)=-\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mclose">)</span></span></span></span></span></p>
<p>由此可见，我们通过H门处理量子比特，能够将解问题转为相位变化的问题，那么整个解空间可表示为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><msup><mo>⊕</mo><mi>n</mi></msup><mo><mover><mo><mo>⟶</mo></mo><mtext> Hadamard </mtext></mover></mo><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>N</mi></msqrt></mfrac><munder><mo>∑</mo><mi>x</mi></munder><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|0\rangle \oplus^{n} \stackrel{\text { Hadamard }}{\longrightarrow}|\psi\rangle=\frac{1}{\sqrt{N}} \sum_{x}|x\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5471080000000001em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mclose">⟩</span><span class="mord"><span class="mbin">⊕</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2971080000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight"> Hadamard </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5714449999999998em;vertical-align:-1.250005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.1833349999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span></span></span></span></span></p>
<p><img src="/assets/image-20210314213511000.png" alt="image-20210314213511000"></p>
<p>再将所有非搜索问题<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N-M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>的解定义为一个量子态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\alpha\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span></span></span></span>，记为（推导方式同上）</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow></msqrt></mfrac><munder><mo>∑</mo><msub><mi>x</mi><mn>1</mn></msub></munder><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\alpha\rangle=\frac{1}{\sqrt{N-M}} \sum_{x_{1}}|x\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.671545em;vertical-align:-1.350105em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2249999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.885em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-2.8449999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15500000000000003em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.350105em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>那么, 令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>为最终的量子态, 且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\alpha\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>正交, 初态可重新表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\psi\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo><mo>=</mo><msqrt><mfrac><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow><mi>N</mi></mfrac></msqrt><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo><mo>+</mo><msqrt><mfrac><mi>M</mi><mi>N</mi></mfrac></msqrt><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\psi\rangle=\sqrt{\frac{N-M}{N}}|\alpha\rangle+\sqrt{\frac{M}{N}}|\beta\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7689599999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.67104em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6310400000000005em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l0 -0c4,-6.7,10,-10,18,-10 H400000
v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80
h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7689599999999999em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7689599999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.67104em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6310400000000005em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l0 -0c4,-6.7,10,-10,18,-10 H400000
v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80
h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7689599999999999em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>将该量子态经过H门，就相当于对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>所在的最终量子态进行了反转操作，上面有说明，得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo><mo>=</mo><msqrt><mfrac><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow><mi>N</mi></mfrac></msqrt><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo><mo>−</mo><msqrt><mfrac><mi>M</mi><mi>N</mi></mfrac></msqrt><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\psi\rangle=\sqrt{\frac{N-M}{N}}|\alpha\rangle-\sqrt{\frac{M}{N}}|\beta\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7689599999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.67104em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6310400000000005em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l0 -0c4,-6.7,10,-10,18,-10 H400000
v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80
h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7689599999999999em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7689599999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.67104em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6310400000000005em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l0 -0c4,-6.7,10,-10,18,-10 H400000
v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80
h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7689599999999999em;"><span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>这相当于关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\alpha\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span></span></span></span>的第一种对称操作，这时还不能将量子态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\Psi\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Ψ</span><span class="mclose">⟩</span></span></span></span>变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>，还需要一个H门将量子态再关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\Psi\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Ψ</span><span class="mclose">⟩</span></span></span></span>对称(第二种对称操作)，这两个对称操作称为一次Grover迭代，假设初态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\Psi\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Ψ</span><span class="mclose">⟩</span></span></span></span>可以表示为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>cos</mi><mo>⁡</mo><mfrac><mi>θ</mi><mn>2</mn></mfrac><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>sin</mi><mo>⁡</mo><mfrac><mi>θ</mi><mn>2</mn></mfrac><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\psi\rangle=\cos \frac{\theta}{2}|\alpha\rangle+\sin \frac{\theta}{2}|\beta\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>现在的目标呢就是通过对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\Psi\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">Ψ</span><span class="mclose">⟩</span></span></span></span>进行Grover迭代，将其映射成为我们的目标解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>，那么经过k次Grover迭代之后，末态为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mi>k</mi></msup><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mi>θ</mi><mo fence="true">)</mo></mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mo stretchy="false">⟩</mo><mo>+</mo><mi>sin</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mi>θ</mi><mo fence="true">)</mo></mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">G^{k}|\psi\rangle=\cos \left(\frac{2 k+1}{2} \theta\right)|\alpha\rangle+\sin \left(\frac{2 k+1}{2} \theta\right)|\beta\rangle
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span></span></p>
<p>可见经过多次迭代，<font color='red'>可以使末态在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>上的概率足够大</font>，最终我们希望得到的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>θ</mi><mo>=</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(2k+1)\theta=\pi/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，这样就能够搜索到想要的方程解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>。根据计算搜索到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>β</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|\beta\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">⟩</span></span></span></span>的概率为（注意：这里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi><mo>=</mo><msqrt><mfrac><mi>M</mi><mi>N</mi></mfrac></msqrt></mrow><annotation encoding="application/x-tex">sin\theta=\sqrt{\frac{M}{N}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.5913344999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2486655000000002em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.2086655em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5913344999999999em;"><span></span></span></span></span></span></span></span></span>,因此才有了后面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>O</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><msup><mn>2</mn><mi>n</mi></msup></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1-O(\frac{1}{2^n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>）</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>β</mi><mi mathvariant="normal">∣</mi><msub><mi>ψ</mi><mi>T</mi></msub><mo>&gt;</mo><msup><mo fence="true">∣</mo><mn>2</mn></msup><mo>=</mo><msup><mo><mi>sin</mi><mo>⁡</mo></mo><mn>2</mn></msup><mo stretchy="false">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>O</mi><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><msup><mn>2</mn><mi>n</mi></msup></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">P=|&lt;\beta| \psi_{T}&gt;\left.\right|^{2}=\sin ^{2}(\frac{2k+1}{2} \theta)=1-O\left(\frac{1}{2^{n}}\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.204008em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mop"><span class="mop">sin</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.871868em;"><span style="top:-3.12076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p>
<p>所以量子搜索的次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>4</mn></mfrac><msqrt><mfrac><msup><mn>2</mn><mi>n</mi></msup><mi>M</mi></mfrac></msqrt><mo>=</mo><mfrac><mi>π</mi><mn>4</mn></mfrac><msqrt><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mi>M</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\frac{\pi}{4} \sqrt{\frac{2^{n}}{M}}=\frac{\pi}{4}\sqrt{N/M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.604946em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.235054em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.195054em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.604946em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.28em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span></span></span></span>，而经典搜索是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2^{n}=N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，相比之下量子搜索实现了根号级别的加速。用图片表示Grover算法的过程如下</p>
<p><img src="/assets/image-20210314220516869.png" alt="image-20210314220516869"></p>
<p><img src="/assets/image-20210314220525440.png" alt="image-20210314220525440"></p>
<p><img src="/assets/image-20210314220534319.png" alt="image-20210314220534319"></p>
<p>然后本周还在准备了<a href="https://competition.huaweicloud.com/codecraft2021#introduction">华为软件精英挑战赛</a>。</p>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>理论基础</category>
      </categories>
  </entry>
  <entry>
    <title>TNML-ACML2020Tutorial</title>
    <url>/2021/03/07/57TNML-ACML2020Tutorial/</url>
    <content><![CDATA[<p><strong>第38页</strong></p>
<p>Knowledge Distillation (Hinton et al., NIPS 2014 Workshop)</p>
<p>Quantization and Sharing of Weight (Han et al., ICLR 2016)</p>
<p>Low-rank Matrix/Tensor Factorization (Novikov et al., NIPS 2015)</p>
<a id="more"></a>
<p><strong>PPT 63页</strong></p>
<p>Generalization of Compressed CNN</p>
<p>目前已有的压缩算法对训练好的权重矩阵进行矩阵/张量分解来完成低秩近似。然而，SOTA网络层，例如VGG和WAN，不必要进行低秩近似。</p>
<p>文中对VGG网络中的权重张量进行CP张量分解，直接的压缩很难实现，并且对微调网络往往需要很大的计算复杂度</p>
<p><img src="/assets/QQ%E6%88%AA%E5%9B%BE20210305102532.png" alt="img"></p>
<p>纵轴Normalized是CP分解的分量振幅(也称为CP频谱)，对应CP分解公式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">X</mi><mo>≈</mo><mo stretchy="false">[</mo><mi mathvariant="bold-italic">λ</mi><mo separator="true">;</mo><mi mathvariant="bold">A</mi><mo separator="true">,</mo><mi mathvariant="bold">B</mi><mo separator="true">,</mo><mi mathvariant="bold">C</mi><mo stretchy="false">]</mo><mo>≡</mo><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><msub><mi>λ</mi><mi>r</mi></msub><msub><mi mathvariant="bold">a</mi><mi>r</mi></msub><mo>∘</mo><msub><mi mathvariant="bold">b</mi><mi>r</mi></msub><mo>∘</mo><msub><mi mathvariant="bold">c</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{X} \approx [ \boldsymbol{\lambda} ; \mathbf{A}, \mathbf{B}, \mathbf{C} ] \equiv \sum_{r=1}^{R} \lambda_{r} \mathbf{a}_{r} \circ \mathbf{b}_{r} \circ \mathbf{c}_{r}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord"><span class="mord boldsymbol">λ</span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">C</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">c</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>为了克服这种限制，文章中提出了一种分层结构设计，CPL(CP Layer)。CPL重新设定了重量张量的参数，以便可以以端到端的方式轻松学习Polyadic形式（CP形式）（Kolda和Bader，2009）。</p>
<p><strong>PPT 75页</strong></p>
<p><strong>提出基于单模态(unimodal)和多模态(multimodal)情感分析的最新方法</strong></p>
<p><img src="/assets/QQ%E6%88%AA%E5%9B%BE20210306152922.png" alt=""></p>
<p><strong>PPT 76页</strong></p>
<p><img src="/assets/QQ%E6%88%AA%E5%9B%BE20210306155909.png" alt="img"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">z_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是不同模态的输入向量(m = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1,...,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>)，这种将不同模态的向量进行外积的方法使得模态数量呈指数式增长<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>d</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\prod_{m=1}^{M}d_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，权重张量的更新复杂度也将指数增长。这样不仅引入了很大的计算量，也更有可能发生过拟合。更为稳妥一点的方法结构(论文创新点)如下所示</p>
<p><img src="/assets/QQ%E6%88%AA%E5%9B%BE20210306160952.png" alt="img"></p>
<p>将各个模态的向量直接与各个分解的r个权重张量进行对应计算，将计算复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><msub><mi>d</mi><mi>y</mi></msub><msubsup><mo>∏</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>d</mi><mi>m</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(d_{y} \prod_{m=1}^{M} d_{m}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>降为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo fence="true">(</mo><msub><mi>d</mi><mi>y</mi></msub><mo>×</mo><mi>r</mi><mo>×</mo><msubsup><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><msub><mi>d</mi><mi>m</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">O\left(d_{y} \times r \times \sum_{m=1}^{M} d_{m}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></p>
<p><strong>GRU Network</strong></p>
<p>GRU(Gated Recurrent Unit) 算法是神经网络算法的一种，在2014年由<a href="https://arxiv.org/pdf/1406.1078v3.pdf">Cho, et al.</a>提出，主要是为了解决标准RNN网络中的梯度消失问题。GRU是LSTM的一种变体，大多数情况下两者都具有极好的实验结果。网络的关键之处在于引入了更新门(update gate)和重置门(reset gate)，它俩决定了要传递的信息，保证与预测有关的信息不会随着时间的流逝而被删除掉，更多内容请看参考链接。</p>
<p><strong>遗留问题</strong></p>
<p>处理数据融合</p>
<p>拓扑结构</p>
<p>引用</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/302453223">深入理解 | CP、Tucker分解</a></li>
<li><a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be">Understanding GRU Networks</a></li>
<li><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></li>
<li><a href="http://proceedings.mlr.press/v108/li20c/li20c.pdf">Understanding Generalization in Deep Learning via Tensor Methods (Li et al., AISTATS 2020)  </a></li>
<li><a href="https://arxiv.org/pdf/1603.00162.pdf">Convolutional Rectifier Networks as Generalized Tensor Decompositions</a></li>
<li><a href="https://arxiv.org/pdf/2005.04366.pdf">Compressing Recurrent Neural Networks Using Hierarchical Tucker Tensor Decomposition</a></li>
<li><a href="https://arxiv.org/pdf/1711.00811.pdf">EXPRESSIVE POWER OF RECURRENT NEURAL NETWORKS</a></li>
<li><a href="https://arxiv.org/pdf/1906.09777.pdf">A Tensorized Transformer for Language Modeling</a></li>
<li><a href="https://arxiv.org/pdf/1705.06676.pdf">MUTAN: Multimodal Tucker Fusion for Visual Question Answering</a></li>
<li><a href="https://arxiv.org/pdf/1707.07250.pdf">Tensor Fusion Network for Multimodal Sentiment Analysis</a></li>
<li><a href="https://openaccess.thecvf.com/content_cvpr_2018/papers/Ye_Learning_Compact_Recurrent_CVPR_2018_paper.pdf">Learning Compact Recurrent Neural Networks with Block-Term Tensor Decomposition</a></li>
<li><a href="https://arxiv.org/pdf/1711.00073.pdf">Long-Term Forecasting using Higher-Order Tensor RNNs</a></li>
<li><a href="https://arxiv.org/pdf/2002.09131.pdf">Convolutional Tensor-Train LSTM for Spatio-Temporal Learning</a></li>
</ol>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>理论基础</category>
      </categories>
  </entry>
  <entry>
    <title>学堂在线---《如何写好科研论文》秋</title>
    <url>/2020/12/14/52PaperWriting/</url>
    <content><![CDATA[<p>学堂在线—<a href="https://www.xuetangx.com/learn/THU04011000365/THU04011000365/4233659/video/6387967">《如何写好科研论文》秋</a></p>
<p>连续阅读相关方向的论文，做一定的积累，一天一篇或者两天一篇，最重要的是感觉不能断，将阅读过程中的一些想法记录下来，同方向的一些经典文章要精读(最少读5遍以上)</p>
<a id="more"></a>
<h3 id="如何写论文">如何写论文</h3>
<ul>
<li>
<p>标题</p>
<p>反应核心技术、尽量精炼简洁、与关键字区别、保护知识产权、不能太大、采用规范形式，如</p>
<p>“xx系统下针对xx问题的xx算法”，”基于xx原理在xx系统下针对xx问题的解决办法“</p>
</li>
<li>
<p>摘要</p>
<p>标题的扩充、覆盖文章的出发点、亮点、效果、200字左右、套路化，如</p>
<p>我们考虑了xx系统中的xx问题，利用xx原理或xx方法研究这个问题，在研究过程中遇到了什么阻碍，然后又采用什么手段解决了这个阻碍，最终达成了什么样的效果。</p>
</li>
<li>
<p>引言</p>
<p>摘要的扩充、研究背景、提出问题及原因</p>
<p>文献调研：内容相关、缺点进行批判</p>
<p>本文贡献</p>
</li>
<li>
<p>问题建模</p>
<p>数学语言描述、选取已有模型、描述要解决的问题</p>
</li>
<li>
<p>方法和分析</p>
<ul>
<li>文字链接所有公式</li>
<li>逻辑清洗顺畅</li>
<li>适当的停顿解释，获得什么样的物理意义、区别、特点</li>
<li>换位思考，从读者的角度出发</li>
<li>掌握一套数学分析工具：扰动法、克拉美罗界</li>
<li>简化表达式</li>
<li>扩充<strong>论文长度</strong>和贡献</li>
</ul>
</li>
<li>
<p>仿真验证</p>
<ul>
<li>规范的形式、坐标</li>
<li>目标明确：复杂度、精度、效率</li>
<li>解释仿真结果，反哺理论</li>
<li>不要有冗余</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>注意与摘要的区别，用过去式来写</li>
<li>未来的方向</li>
</ul>
</li>
<li>
<p>参考文献</p>
<ul>
<li>既定格式</li>
</ul>
</li>
</ul>
<p>一篇论文从初稿到结束，要改10遍左右，历经2，3个月</p>
<p>第一遍写完后第二遍细改，字斟句酌，理清思路</p>
<p>第三遍速度，逻辑通顺，休息一段时间再改第四遍</p>
<p>语法正确之后，还会有Chinese english的问题，这个不能一蹴而就，只能积累，最后逻辑一定要严谨，将文章前后的逻辑关系理清。</p>
<img src='/assets/1608120155242.png' width='60%'>
<p><img src="/assets/1608120420420.png" alt="1608120420420"></p>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>论文写作</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习小结</title>
    <url>/2020/12/08/51DeepLearning/</url>
    <content><![CDATA[<p>我接触深度学习已经有一段时间了，特别是现在读研究生还是离不开机器学习这方面的内容，因此我需要不断地提高这方面的水平，每一次编码都要比以往更加<strong>规范、高效并提高封装效果</strong>以便于快速的进行二次开发，而不能仅仅水平一直停留在<strong>复制粘贴、调包</strong>的程度，很多小工具需要弄清出工作原理，不一定都要复现，但出了问题一定要第一时间能够修改和调试。</p>
<a id="more"></a>
<p>目前比较常用的深度学习框架有很多，有大家都很熟悉的<strong>Tensorflow，有Pytorch，还有Keras、Caffe、PaddlePaddle</strong>等等。我主要用过前三种，对Pytorch最为熟悉，还在Coursera上学习过一整套Pytorch的教程。在进行机器学习或深度学习开发的过程中，需要学习优秀的开源代码，并对照着不断完善自己的代码，这样才能提高，而不仅仅是为了完成某一个功能而进行的开发，要考虑其<strong>简洁性</strong>、<strong>效率</strong>、<strong>复用性</strong>等因素，还要适当的提高内存使用的效率，同时为了便于推广，还要适当的添加一些必要的注释。</p>
<p>今天是2020年12月8日，随着项目<strong>Experiments_HTN</strong>实验内容的增加，代码重复性很高，而且因为参数的缘故显得十分的臃肿，并且数据集非常大显然是不能直接提交到github上进行保存的，管理和复用时极其不方便，因此，我查阅了一些github上比较优秀的开源项目，想从中学习一些代码管理经验，特别是参数和数据的处理方式。以下开源的项目在一定程度上给了我一些有用的参考</p>
<ul>
<li>
<p><a href="https://github.com/gaussic/text-classification-cnn-rnn">text-classification-cnn-rnn</a>：<strong>3.3K Star</strong>;<strong>1.3K Fork</strong>，该项目使用卷积神经网络以及循环神经网络进行中文文本分类。尽管它采用的是tensorflow框架，但其模型及其参数定义的很简洁，即定义一个Config类来对参数进行管理，是目前我非常欣赏的一种方式</p>
</li>
<li>
<p><a href="https://github.com/ultralytics/yolov5">yolov5</a>：<strong>6.8K Star;2.2 K Fork</strong>，该项目用于目标检测的研究，采用Pytorch框架，提供了一些较好的模型断点可以用于迁移学习，该项目的参数主要是通过argparse来输入及调用，还有一些参数直接放在函数传参入口</p>
</li>
<li>
<p><a href="https://github.com/ouyanghuiyu/chineseocr_lite">chineseocr_lite</a>：<strong>6K Star;1.2K Fork</strong>中文OCR，支持竖排文字识别，NCNN推理，没有采用上述框架，其参数也是定义在Config文件中</p>
</li>
</ul>
<p>其他还有很多项目，这里就不一一列举了。总的来说，我发现国外的Coder更倾向于将模型的众多参数通过argparse调用，可能是他们大多数采用linux的环境进行开发，这时显然这种方式更加具有优势。而对国内的Coder更倾向将模型的参数保存在一个文件(.yml/.py/.json)中，或者保存在一个单独的类中。</p>
<p>总之，我还是更能接受将参数保存在类中。由于HTN在实验过程中，经常会采用不同框架的代码，不同更新方式的模型，不同种类的数据(mnist/fashion-mnist/X-ray_Image/cifar10)，因此将数据统一下载或保存到根目录<code>./dataset/</code>下，使得不同框架的模型可以共享，而不同的框架和模型则用不同的文件夹进行区分。至于较大的自定义数据集暂时先存在服务器上，供大家下载。</p>
<p>参考</p>
<p><em>1. <a href="https://awesomeopensource.com/projects/pytorch">Pytorch开源项目汇总</a></em></p>
<p><em>2.<a href="https://zhuanlan.zhihu.com/p/28475866">吐血整理：PyTorch项目代码与资源列表 | 资源下载</a></em></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络应用——基于DNS绕开校园网认证</title>
    <url>/2020/11/29/48PassbyCpsNet/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章我想分享一下我与校园网斗智斗勇的过程哈哈哈</p>
</blockquote>
<a id="more"></a>
<p>本科的时候，学校的wifi网络是由学校自己负责，通过校园卡进行管理，每个月送20G，多余的1块1G，网络稳定性和速度也都还可以接受，实验和上机不需要自己额外出网费，这种方式也蛮好的（现在我更是怀念这种方式）。至于电话卡，纯属是为了流量和通话方便，那个时候全国流量和全国通话还比较贵，因此我就办了一张，摒弃了我在老家的那张电话卡，因为我觉得维持多个电话卡对我来说是一种负担。</p>
<p>后来我读研了换了一个地方，然后我发现新学校的校园wifi网络竟然全都由运营商来负责，当然也可以在学校购买流量，但在学校购买的流量有两种计费方式，一种是0.4元一个小时，另一种好像是1块钱3G，具体记得不太清楚了，总之很不实用，就是在逼你去办校园卡（校园卡不限制流量的39元/月）。其实这个价钱忍痛也能接受，可就是你要换当地的手机号，这一点让我极其不爽。我不太想用两个手机号，更不想以这种方式妥协。</p>
<p>通过同学，我知道了一些借助DNS服务器UDP53端口可以绕开校园网认证，于是我就尝试自己去搭梯子（借助我的阿里云服务器），搭了快一天，结果因为某些未知的配置原因，始终连不上，于是我开始寻求现成搭好的oven文件。后来我在网上查的时候知道了<strong>无为wifi</strong>，于是就下载了这个应用，注册了个账户，每个月6元，也不算很贵，算是基础版本吧，能够通过DNS服务器访问国内网络。</p>
<p>但是好景不长，用的时间一长我发现这个工具网速极其慢，并且很不稳定，经常断，这不仅没让我方便还让我得花时间去折腾。于是在今天早上它又宕机的时候，我实在忍不了了，又去网上找，看到了几个但是还没试，正好想起之前在配置Openvpn的时候加的一个这方面的好友，请教了一下，知道了<strong>知速云</strong>这个平台，花了几个小时尝试了一下，速度好快的</p>
<p><img src="/assets/1606621555495.png" alt="1606621555495"></p>
<p>手机端也配置测试了一下，速度差不多，这样即使在晚上人多的时候也不至于太慢，因此在这里安利一下哈哈哈，目前用着还没发现什么问题，网速快了以后心情也好多了哈哈。</p>
]]></content>
      <categories>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>骚操作</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetcodeSummary</title>
    <url>/2020/11/13/45LeetcodeSummary/</url>
    <content><![CDATA[<p>Leetcode算法刷题总结</p>
<a id="more"></a>
<p>起初，我在leetcode上的刷题是极其盲目的，每次都是Random Pick One algorithm。尽管这个习惯能养成，但是无论从<strong>效果上和效率上</strong>，我都提升的极其缓慢。并且很多时候对于Medium或者Hard的题，即使我把笔啃断也解不出来，又不肯看答案或者看完就忘，所以不仅严重打击我的Confidence，而且还没有效果。</p>
<p>我觉得这样下去不是办法呀，于是我就想着刷专题，每个专题(Tag)的解法、思路、最优解都搞定之后再切换成Random的形式。于是我刷完了LinkList，当我准备寻找下一个Tag时，我迟疑了，因为Tag实在太多了几十多个。而且这样做的一个弊端就是在解题之前，已知这题的类型，而不会去关注对题目的判断。</p>
<p>我从各类文章中吸取到的一些注意事项如下</p>
<ul>
<li>**对于新人而言，不应该自己硬扣一个题目，如果想了一会没有任何思路，就应该果断看别人怎么写的。在理解了别人的做法之后，再凭理解和记忆在LeetCode的代码框里敲一遍。**新手不要害怕看别人的解法和答案，度过痛苦时期，后面就会越刷越快。新手应该注重三个方面：基础知识、跟别人学习、做好笔记 。</li>
</ul>
<p>我觉得大部分题目的基础知识我是有的，但是在<strong>跟别人学习</strong>和<strong>做笔记</strong>这方面开展的不太好。至于入门教程和方向，我觉得仅关注这个Github项目就够了：<a href="https://github.com/labuladong/fucking-algorithm">fucking-algorithm</a></p>
<p>参考文章</p>
<p><a href="https://leetcode.com/discuss/career/450215/How-to-use-LeetCode-to-help-yourself-efficiently-and-effectively-(for-beginners)">1. How to use LeetCode to help yourself efficiently and effectively (for beginners)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《刻意练习》读书笔记</title>
    <url>/2020/09/30/39DelibratePractice/</url>
    <content><![CDATA[<p>训练时长和训练方法</p>
<p>训练方法可能是间断性调整的（往往在当前方法遇到瓶颈，无法提高时）</p>
<p><strong>在任何行业或者领域中，最有效和最强大的那类联系，都通过充分利用人类的身体与大脑的适应能力，来逐步的塑造和提升他们的技能，以做到一些过去不可能的事情。</strong></p>
<a id="more"></a>
<p>我们在学习任何一项技能时，从烘焙饼干到写一段说明文，我们全都遵循相同的模式。首先，一般性的了解我们想做些什么，从导师、教练、书籍或网站上获得一些指导，然后一直练习，直到达到我们可以接受的水平，接下来让这种技能变成自动的、自然而然的。<strong>当我们的水平达到这个地步，我们就遇到了我们第一个瓶颈</strong>，那就是无论我们重复多少次，我们都很难再有大的提升。</p>
<p>但是人们经常错误的理解这种现象，认为开了20多年的司机一定比开了5年的司机更擅长开车；行医二十年的医生，一定会纸币行医5年的医生更加优秀；教了20年书的老师，一定会比只教了5年书的老师能力更强。</p>
<p>但是现实并不是这样。研究表明，一旦某个人的表现达到了“可接受”的水平，那么再多练习几年，也不会再有什么进步。原因在于，<strong>如果没有刻意的去思考如何提高，这些自动化的能力会缓缓退化</strong>。</p>
<h2 id="9月23日-更新-第二章：大脑的适应能力">9月23日 更新 第二章：大脑的适应能力</h2>
<p>这一章主要是分析了刻意练习产生效果的内在科学依据。我们在运动或者健身时，通过一次次的练习，能够明显的看到或感受到肱二头肌、肱三头肌这些肌肉的变化。然而在进行一些复杂的脑力活动或者训练时，我们很难直观的看到自身的变化，我们的脑袋不会变大、变硬，也不会长出犄角。但这不意味着它是一成不变的，当我们进行<strong>记忆数字、数算等复杂脑力活动</strong>时，神经元及组织之间的链接是会发生<strong>强弱变化</strong>的。</p>
<p>研究表明，伦敦司机大脑的<strong>海马体</strong>要比普通人大一些，当然这并不意味着这是<strong>幸存者偏差</strong>导致的，一组关于伦敦司机培训前后海马体的比较能够说明这一点。这一点与发过生物学家“拉马克”的“<strong>用进废退</strong>”思路比较一致，通过不断地走出舒适区，我们大脑能够逐渐<strong>适应新的、更加复杂的神经元回路</strong>，就能实现逐步提高的结果。</p>
<p>刻意练习与传统的练习方式不同之处在于，传统练习刚刚离开舒适区，更多的倾向于找到我们身体的潜能。而刻意练习的思路意味着，我们通过训练可以做到任何其他人可以完成的事情（例如长跑、俯卧撑、记忆数字等等）。</p>
<p>当然我们总是希望我们热爱或者从事的任何一件事情都能通过<strong>刻意练习</strong>来提高，但是有两点情况你需要知道</p>
<ol>
<li>通过刻意练习强化某一部分神经元的同时，相同区域的负责其他功能的神经元可能退化（当然这一点是正常的， 任何不重复、不提高的区域都会逐渐退化）。</li>
<li>每一次的刻意训练都需要全身贯注，经常性的反思（但我们的注意力是有限的）</li>
</ol>
<p>因此，想真正的将其应用于生活，或许应该首先关注<strong>我们每天都要做的、非常重要</strong>的事情，不断地走出舒适区，不断地挑战自我，直到这方面技能达到一个<strong>令你满意</strong>、且<strong>适应而不费力</strong>的地步。</p>
<h2 id="9月24日更新-第三章：心理表征">9月24日更新 第三章：心理表征</h2>
<p>在这一章作者列举了大量的例子来帮助我们去理解<strong>心理表征</strong>的<strong>定义、作用、训练方式</strong>等等。用我自己的话而言，心理表征就是一个人在某个领域的<strong>知识</strong>、<strong>技能</strong>、<strong>经验</strong>、<strong>直觉</strong>、<strong>判断</strong>等一系列内容的整合。</p>
<p>就像<strong>国际象棋</strong>的棋手阿廖欣的故事一样，他能够同时下25局盲棋，并且获得惊人的战绩，同时他也是多届国际象棋的冠军。对于一盘正在下的象棋，象棋大师能够在短短的几步之内迅速记住<strong>整个棋局的布局和关键棋子</strong>，而新手只能记住很少一部分。这难道是因为象棋大师有超高的记忆力么？哈哈，显然不是，当他们和普通选手同时记忆一堆杂乱无序的棋子时，他们的表现并没有比正常人强多少。这说明问题的关键不在于记忆力，而在于象棋大师具有复杂、精细的<strong>心理表征</strong>，大师对象棋的心理表征基于<strong>规则、局势、关键路数</strong>等，他们能将这些信息整合到一起，从而能够快速的记忆和回忆棋局。</p>
<p>再举一个例子，足球运动员，在我们观众看来，那么大的足球场，足球员的跑步的方向、步伐杂乱无章，球场一片混乱。可在足球高手看来，每个人都有自己的位置和负责的区域，并且他们的运动都是以球为中心。并且每个球员的传球方式、动作等在足球高手眼里都是非常有用的信息，他们能够知道谁在帮他们拦截、他们的<strong>最佳射球点位置、传球方式、几种进球方案</strong>等等，越熟练的高手越能在极短的时间做出判断，并采取行动。这在比赛中，能赢得更多的时间，也能提高射球准确率。上述的这些反应、预判、思考都是足球高手进行长期的训练和有监督的指导所形成的<strong>心里表征</strong>。</p>
<p>当然书中还列举了医生、体操运动员等不同领域的专业人士的心里表征的具体体现，心里表征能够帮助我们<strong>预判未来</strong>、<strong>制定计划</strong>、<strong>找出规律</strong>、<strong>高效学习</strong>。就像做数学题，高手怎么做呢，根据题目的条件迅速列举可实施的几种方法，根据时间、答题情况等综合考虑选择的方法是<strong>快速求解</strong>、还是<strong>稳健易算</strong>等，这都是在平时多次总结、积累、训练得到的。心理表征随着我们能力的提高会进一步发挥作用。</p>
<h2 id="9月28日更新-第四章-黄金标准">9月28日更新 第四章 黄金标准</h2>
<p>刻意练习的定义非常严格，你需要一位导师或者教练来教你练习的方法，来帮助你提高特定的技能。这个行业或者领域本身必须拥有一套高度发达的技能，可以用来教给业内人士。符合这些所有条件的领域很少，仅包括音乐表演、国际象棋、芭蕾、体操以及一些行业或领域。</p>
<p>但是就像史蒂夫记忆数字一样，他一样没有人指导，他的提高是通过反复实验来想办法提高的。当参赛者找不到导师来帮助设计训练课程时，他们能从以前的专家那里获取建议、那些专家的事迹，<font color='red'><strong>要么可从书上找到，要么可以从媒体的采访中获得</strong></font>，如果在你所处的领域中<strong>刻意练习</strong>原则可以实行，那么采用它进行训练；如果不是，就要尽量采用刻意练习的原则，实践中分为以下几个步骤：</p>
<ol>
<li>辨别杰出人物：要有不含偏见的客观、不要比时间长、可以请教身边给专业人士提供帮助的人（不禁要问谁厉害，还要问他们是如何判断的）。关键是<strong>客观的、可复制</strong>的指标</li>
<li>找杰出人物和其他人的差别：思考他们做了什么、有什么练习方法，自己要不断调整。同时找到优秀的导师，最重要的是从他那里得到反馈。</li>
<li>训练方法</li>
<li>坚持练习</li>
</ol>
<h2 id="9月30日更新-第五章-在工作中运用刻意练习的原则">9月30日更新 第五章 在工作中运用刻意练习的原则</h2>
<p>医生和护士的讲座或者研讨会没有反馈，没有复杂的现实环境。</p>
<p>专业学院着重于知识，而不是技能。人们一般认为有了知识，就能掌握技能。但是很多领域例如医学并没有这样的套件</p>
<p>所以有效的方法是<strong>制定改进技能的培训方法</strong>，强调实干，而不是知晓</p>
<p>外科与其他专科的不同，例如血管破裂组织损伤，能够立马暴露出来，即使反馈，知道哪错了。</p>
<p>杰出医生做好计划、监控手术、准备临场应变。有有效的心理表征</p>
<h2 id="10月2日更新-第六章-在生活中运用刻意练习原则">10月2日更新  第六章 在生活中运用刻意练习原则</h2>
<p><strong>刻意练习针对每一个有梦想的人</strong></p>
<p>首先，找一位好导师，你可以看视频、参加团体课，但无论看多少遍示范，但你依然会注意不到或者理解错某些细节，有时甚至还忽略了并不细微的事情。而且即使你发现自己的缺陷，也无法想出最好的方法来弥补。尤其是，你的心理表征将存在问题。</p>
<p>导师的选择也有一定的要求，不是越优秀、杰出的导师越好，要看其他人对老师的评价、老师的熟练度和经验。导师最重要的事情是帮助你建立<strong>心理表征</strong>，以便能够检测和纠正自己的表现。<strong>当自己改变了时，可能需要更换导师。</strong></p>
<p>要记住：如果你在走神，或者你很放松，并且只为了好玩，你可能不会进步。</p>
<p>没有导师怎么办、富兰克林的例子、要自己设计练习方法。。为了提高，我们必须自己创造机会</p>
<p>在没有导师时，要学会利用3个F自己创建有效的心理表征，即：专注、反馈和纠正。<strong>将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决他们。</strong></p>
<p>当我们自己设计练习方法并付诸于行动时，我们的经历往往时这样的，在训练初期我们的能力进步神速，或者至少是稳步前进，这十分正常。然而，当那样的进步停滞下来时，你就是遇到了自己的第一个<strong>瓶颈</strong>。这个瓶颈就像<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></p>
<p>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>处局部收敛一样，很难跨越这个局部最优值，于是算法包里给出了momentum这个参数，就是再给这个点加一个动量来帮助它跳出局部最优值。那么同样，当我们刻意练习遇到瓶颈时，我们可以<strong>尝试不同的训练方法，增大或减少训练量，请教老师或者同学，调整训练计划</strong>等作为我们<strong>突破瓶颈的动量</strong>。</p>
<p>当然，这里还会有一个非常重要且普遍的问题：新年决心效应</p>
<p>有目的的练习是一项艰巨的任务。它难以坚持下去，即使你仍然在坚持练习，比如你还是经常去健身房、或者每个星期花很多时间来练习吉他，但你<strong>难以保持专注和努力</strong>，因此，到最后你不再推动自己前进，而且不在进步。问题是你可以做些什么来改变呢？是意志力么，显然不是。</p>
<p>保持动机要将它养成习惯，并且不断的强化自己的动机，尽可能减小自己练习遇到的阻碍和变动性</p>
<p><strong>遇到瓶颈怎么处理？</strong></p>
<p>尝试做不同的事情，而非更难的事情.</p>
<p>有目的练习的特点</p>
<ol>
<li>有定义明确的特定目标</li>
<li>专注于任务</li>
<li>包含反馈</li>
<li>走出舒适区</li>
</ol>
<p>相关链接</p>
<p><a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9880086237340105012%22%7D&amp;n_type=0&amp;p_from=1"><em>孙光宇—应届硕士被建议破格授予博士学位</em></a></p>
<p><a href="https://baike.baidu.com/item/%E9%87%91%E8%B4%A4%E6%95%8F"><em>金贤敏</em></a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>刻意练习</tag>
      </tags>
  </entry>
  <entry>
    <title>生成个人相册</title>
    <url>/2020/08/20/32GenPerAlbum/</url>
    <content><![CDATA[<blockquote>
<p>本文章讲解如何利用cos桶+cosbrowser在服务器上构建自己的个人相册</p>
</blockquote>
<a id="more"></a>
<p>在这里梳理一下构建相册的基本思路</p>
<ol>
<li>直接将图片放到服务器上，通过<strong>相对路径</strong>或<strong>网络路径</strong>进行索引。这种方式操作起来不难，但是过程比较繁杂，一方面是图片链接需要一个个<strong>复制粘贴</strong>，另一方面大尺寸图片加载速度<strong>很慢</strong>。</li>
<li>将图片上传到图床上（可理解为一个自动生成图片链接的容器），这样一键能批量生成各种各样的图片链接，但是它们还是需要设计布局并通过src引用到页面上</li>
<li>图床+js脚本，自动读取存储路径下的图片进行页面部署（相当于有了个<a href="https://github.com/Lruihao/cos-album"><strong>模板</strong></a>），这个模板搭配着<strong>图床</strong>将事半功倍，如果你的图床还有CDN加速，那就能加快页面加载速度。</li>
</ol>
<p>本博客使用的是第三种方式，效果见<a href="http://182.92.108.27/album/">这里</a>。创建<strong>cos桶</strong>(用作图床)以及上传文件一般都没什么问题，要格外注意cos桶的权限，包含<strong>policy</strong>和<strong>跨域访问CORS设置</strong>这两部分内容的设置，能够通过网页正常访问https://album-1259511784.cos.ap-chongqing.myqcloud.com格式的域名之后，才能正常读取cos桶的图片系列。读取<a href="https://console.cloud.tencent.com/cos5">cos桶</a>图片并布局成为相册的内容见<a href="https://github.com/Lruihao/cos-album">这里</a></p>
<p>参考链接</p>
<ol>
<li><a href="https://me.idealli.com/post/73ad4183.html">给HEXO静态博客添加动态相册功能</a></li>
<li><a href="https://lruihao.cn/posts/cos-album.html">利用腾讯云为静态页面添加 “动态” 相册</a></li>
</ol>
]]></content>
      <categories>
        <category>网站建设</category>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生素养提升公益课</title>
    <url>/2020/08/16/31Study-Report(0810-0816)/</url>
    <content><![CDATA[<blockquote>
<p>本周主要是观看学习了知网研学研究生素养提升课，以及学习层次树张量网络的英文论文（Liu_2019_New_J._Phys._21_073059）和代码。</p>
</blockquote>
<a id="more"></a>
<h2 id="一-研究生素养提升公益课">一、研究生素养提升公益课</h2>
<p>此系列讲座持续了3天，各个学校的老师和教授们从研究生入学要求、到论文的写作、到研究生学习规划，全方位的扩展了我们的认知，记录了其中一些重点内容，总结如下</p>
<p><strong>北京印刷学院 魏超 学术训练和论文体裁</strong></p>
<p>魏老师从一个比较宽泛、基础性的概念讲解了研究生的培养目标、学习条件等等，以及一些与期刊相关的常识。下图是期刊的类型，我们研究生发表的大部分都是学术期刊，不同学校对发表文章有不同的毕业或答辩要求。</p>
<p><img src="/assets/5c2eb28d00589bc4cc66780729f5aeb0.png" alt=""></p>
<p><strong>清华大学 王媛教授 中外文数据库的使用</strong></p>
<p>王媛教授主要是通过一些例子，讲解了文献检索的过程和技巧，并带领我们全面认识学术信息资源。其中一些知识点如下</p>
<ul>
<li>
<p>利用信息创造新知识，合理参与学习社区</p>
</li>
<li>
<p>一个高信息素养的人避免以下行为</p>
</li>
</ul>
<ol>
<li>
<p>在课程论文中引用来自“百度百科”或“Wikipedia”的词条</p>
</li>
<li>
<p>把搜索引擎当做唯一的信息检索工具</p>
</li>
<li>
<p>对信息的生产者和发布者不加以区分</p>
</li>
</ol>
<ul>
<li>
<p>科技期刊Science、Nature、Cell</p>
</li>
<li>
<p>学术发现工具：FirstSearch/Worldcat</p>
</li>
</ul>
<p><img src="/assets/30f2b67002584b92b3bd4b8ff0b2ebd5.jpg" alt=""></p>
<p><strong>中国知网 徐铭梓 如何利用中国知网高效检索文献、阅读和写作</strong></p>
<p>在听这节课之前，我对知网的认知还仅限于查重和搜索。在完整的听完徐铭梓老师的细致讲解之后，才发现知网提供了如此多的功能。包括高级搜索、趋势图标、论文写作、论文发表等一系列的平台，很开阔我的视野。下面是知网研学的写作界面，右侧是摘录的笔记或参考文献，可以随时查看和引用。不知道学校是否开通了这个服务，如果能用可就太舒服了。</p>
<p><img src="/assets/c2a475dfbbe6735bc5e028e4325e3ab2.png" alt=""></p>
<p><strong>北京化工大学 张杰  论文写作技巧与投稿发表</strong></p>
<p>张杰老师讲解了科技论文构成要素及写作要点，并带领我们阅读了几篇论文，教我们如何去快速获取论文的核心观点和结论，以及阅读或写作时要注意的一些细节问题，下图是在投稿之前要注意到的一些技巧。</p>
<p><img src="/assets/3b8037cdcf04a4a842adf5aacfee3e83.png" alt=""></p>
<p>经过几天的学习，我收获了很多有用的知识，同时也非常感谢知网平台提供给我这样一个结课证书，希望能在以后将上面的知识应用到实践中去。</p>
<p><img src="/assets/003d860e20e8f15870553899f690235b.jpg" alt=""></p>
<p>**层次树结构酉张量网络的机器学习       **</p>
<p><img src="/assets/e35a58d3867ee8c1559ef037ff1dc992.png" alt=""></p>
<p>这篇英文论文涵盖了非常多的内容，并且附有代码。在读论文和读代码时遇到各种各样的问题，但是能够相互印证自行解决。论文中不明白的公式演化过程，都能在代码中得到明确的体现。在代码中看不懂的变量和参数，在论文中也有部分体现。总之，这套代码基于python库<a href="https://github.com/andrewdarmawan/tncontract">tncontract</a>来进行张量网络的缩并操作，重难点都已经写在PPT里了。数据集也已经修复，详细的内容见PPT和<br>
<a href="https://github.com/YuleZhang/Tree-Tensor-Networks-in-Machine-Learning"></a></p>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>综合素质</tag>
      </tags>
  </entry>
  <entry>
    <title>图片映射+TEBD+DMRG</title>
    <url>/2020/08/09/30Study-Report(0802-0809)/</url>
    <content><![CDATA[<blockquote>
<p>矩阵乘积态MPS表达多体系统基态</p>
</blockquote>
<a id="more"></a>
<p>TT分解的过程： 已知一个基态对应的高阶张量的样子，然后经过TT分解得到MPS态。<br>
而MPS的关键在于，我们在不知道<strong>指数复杂的量子态系数是什么</strong>，也不需要TT分解，而是直接**假设基态具有MPS的形式，直接处理MPS中的局域张量，**从而绕过了指数墙的问题。</p>
<h3 id="mps的形式可以进行变换">MPS的形式可以进行变换</h3>
<p>同一个量子态可以用不同的tensor进行表达，这种变换称为<strong>规范变换</strong></p>
<p><img src="/assets/2df48437508948713ffb813501230b8b.png" alt=""></p>
<p><strong>如何验证不同的规范变换表示同一个量子态呢？</strong></p>
<p>答：将两者都变换成中心正交形式的MPS态，两者变换结果一致说明同一个量子态</p>
<h3 id="如何将图片映射为张量网络">如何将图片映射为张量网络</h3>
<p>视频中使用的代码和示例都是采用的<strong>虚拟数据</strong>（无实际含义），通过<strong>裁减误差</strong>来刻画算法的性能。而将该算法实际运用到生活中时则涉及到很多的表示问题，我们对图片过去的印象是它是一个**四阶张量，**即（samples,<br>
height, width,<br>
channels），以此为输入可以完成很多的工作。可是当我们对单张图片进行张量网络优化时，就会出现表示难题。仍可以从图片各个指标的角度逐步将其拆解，组合成各种各样结构的网络。如下图</p>
<p><img src="./assets/ad43d1a92637073d925cf710f68b50d3.png" alt=""></p>
<p><img src="/assets/b52e0e04b41996b2f80efbd6341c76e5.png" alt=""></p>
<h3 id="tebd算法：">TEBD算法：</h3>
<p>对于一个W*H的张量网络，在规定求和的顺序后可以将它严格求出。当W或H比较大的时候，这个张量网络的复杂度就呈指数级别增长，传统计算机不能在有效时间内给出结果。而TEBD就是一种基于矩阵乘积态的、近似收缩张量网络的数值算法。</p>
<p>主要思路：从处于边界的张量构成的MPS开始，一行一行（或一列一列）地收缩张量网络。</p>
<p><img src="/assets/4df70ce5f5596569ebffc5edb23c92b5.png" alt=""></p>
<p><img src="/assets/6d3020c3b66f0a65b26f7a381fd2cbbe.png" alt=""></p>
<p>TEBD的计算方案并不唯一，它可以采用MPO的形式，逐层进行求和。也可以采用张量</p>
<p>TEBD算法计算基态的思路是退火，而密度矩阵重整化（DMRG）采取的是另一种思路：</p>
<p><strong>基于最大本征态求解对应的最优化问题，<strong>即求解如下</strong>极小化问题</strong></p>
<h3 id="dmrg算法">DMRG算法</h3>
<p>DMRG的策略是<strong>更新各个张量，使能量达到极小</strong>，具体的更新策略不唯一。在单点（one-site）DMRG中，每次更新MPS中的一个张量，其余张量看成是给定的参数。单个张量的优化问题可以等价为局域矩阵的最大本征值问题。</p>
<p><img src="/assets/1e88c0c1114804d85411c8a82aac0a28.png" alt=""></p>
<p><img src="/assets/ce70bc9a0007fc1827b7bd40826c251d.png" alt=""></p>
<p><img src="/assets/10ef8e487ea1097d3d92ab7d54aa83f0.png" alt=""></p>
<p>有效哈密顿量h2的能量就能用如上的公式和张量网络图来表示。由于它采用的是（Alternating<br>
Least Square,<br>
ALS的方法），故需要反复的迭代更新A1，A2….各个张量，这个地方一般迭代50多次就可以收敛了，计算复杂度线性增加，不会出现指数爆炸问题。同时在计算过程中，可以通过移动正交中心简化计算。</p>
<p><img src="/assets/96e6b943dcdbf857cb383b269e341c43.png" alt=""></p>
<h3 id="张量网络态与深度学习的交融">张量网络态与深度学习的交融</h3>
<p>深度学习在物理方面的应用：</p>
<ul>
<li>
<p>表示量子多体波函数：RBM</p>
</li>
<li>
<p>探测相位过渡</p>
</li>
<li>
<p>蒙特卡罗模拟加速：Self-learning</p>
</li>
<li>
<p>辅助材料的合成</p>
</li>
<li>
<p>张量网络的优化</p>
</li>
</ul>
<p>量子多体物理在DL中的应用</p>
<ul>
<li>
<p>发掘神经网络的新结构</p>
</li>
<li>
<p>生成模型新的表示方法</p>
</li>
<li>
<p>光学神经网络</p>
</li>
</ul>
<p>一般性的深度神经网络结构图如下所示，包含了**输入层、多个隐藏层、输出层。<strong>中间通过各种各样的</strong>线性变换和非线性变换。<br>
**最终不断地训练参数，从而找到某个问题的最优近似解。这里有两个定理</p>
<ol>
<li>
<p>神经网络能够以任意精度逼近所求问题的解，也就是神经网络层数或者神经元个数可以无限延伸</p>
</li>
<li>
<p>没有免费午餐理论，虽然能够有很强的表示能力，但不一定能找到最优结构</p>
</li>
</ol>
<p><img src="/assets/5cb19173f8a2bdddc73f8e10dd315d1d.png" alt=""></p>
<p><strong>神经网络结构和张量网络的对应，请看下图，张量网络毫无压力的可以表示多层神经网络结构！<strong>通过对MPS态的进一步优化就可以实现对网络结构的优化，这种方式极大的减少了神经网络的</strong>权重参数</strong>。</p>
<p><img src="/assets/7378baf0b60c1e8445a0e7e38e15e22b.png" alt=""></p>
<p>同时作者通过大量的实验表示通过MPS结构进行的训练准确率与原神经网络结构基本一致，但是极大地减少了参数个数，优化了网络结构。</p>
<h3 id="算法代码实现">算法代码实现</h3>
<p>本周实现了基于约化密度矩阵的K2DPCA算法处理图像数据，并且在原先水平方向等距约化的基础上增加了垂直方向的处理。</p>
<p>其中水平方向处理如下图所示</p>
<p><img src="/assets/79b69b753ae09e28ddbf1bf3a61efd3a.png" alt=""></p>
<p>垂直方向处理如下图所示</p>
<p><img src="/assets/49c06a504b39d94c5b1ea7f0fc3b4080.png" alt=""></p>
<p>综合水平与垂直方向的处理如下图所示</p>
<p><img src="/assets/da6583c32cf8c10e6cc136b6a1956265.png" alt=""></p>
<p>接下来的实现思路就是通过2-3次这样的矩阵约化，来降低图片的维数，最后通过张量平均的方式代入运算，降低误差。</p>
]]></content>
      <categories>
        <category>周汇报</category>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>图片压缩</tag>
        <tag>张量基础</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/2020/04/03/27Decision-Tree/</url>
    <content><![CDATA[<blockquote>
<p>本文部分图片、材料来自于课程<a href="https://github.com/liuyubobobo/Play-with-Machine-Learning-Algorithms">Python3 入门机器学习</a></p>
</blockquote>
<p>先来看一个招聘的例子，这就是一颗决策树，根据不同的问题进行一步步划分，最终将结果氛围录用和考察两类</p>
<a id="more"></a>
<p><img src="/assets/1585905261759.png" alt="1585905261759"></p>
<h3 id="决策树实例">决策树实例</h3>
<p>采用sklearn的决策树算法包，见<a href="https://github.com/liuyubobobo/Play-with-Machine-Learning-Algorithms/blob/master/12-Decision-Tree/01-What-is-Decision-Tree/01-What-is-Decision-Tree.ipynb"><strong>What-is-Decision-Tree</strong></a></p>
<h3 id="决策树的特点">决策树的特点</h3>
<ul>
<li>
<p>非参数学习方法</p>
</li>
<li>
<p>可以解决分类问题</p>
</li>
<li>
<p>天然可以解决多分类问题</p>
</li>
<li>
<p>也可以解决回归问题</p>
</li>
<li>
<p>具有非常好的可解释性</p>
</li>
</ul>
<h3 id="关键问题">关键问题</h3>
<ul>
<li>
<p>每个节点在哪个维度做划分</p>
</li>
<li>
<p>某个维度在哪个值上做划分</p>
</li>
</ul>
<h3 id="信息熵">信息熵</h3>
<p>熵在信息论中代表随机变量不确定度的度量</p>
<ul>
<li>熵越大，数据的不确定性越高</li>
<li>熵越小，数据的不确定性越低</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mo>∑</mo><msub><mi>p</mi><mi>i</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Entropy(S) = -\sum p_ilog(p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>二分类问题的信息熵效果图，当两个分类的p都为0.5时，信息熵最大，数据越不稳定</p>
<p><img src="/assets/1585912118170.png" alt="1585912118170"></p>
<h3 id="基尼系数">基尼系数</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mn>1</mn><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi>p</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">G = 1 - \sum_{i=1}^{k}p^2_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>同信息熵类似，G越大表示样本的不确定性越强，反之则表示样本的分类没有任何不确定，最小值为0</p>
<p>以二分类为例，其函数图像为开口向下的抛物线</p>
<blockquote>
<p>np.argsort()将np.array中的值从小到大进行排序，按照此顺序依次返回元素在元数组中的index</p>
<p>Counter参数为list，求出列表中值的出现次数</p>
</blockquote>
<h3 id="信息熵vs基尼系数">信息熵VS基尼系数</h3>
<ul>
<li>信息熵的计算比基尼系数稍慢</li>
<li>scikit-learn包中默认参数为基尼系数</li>
<li>大多数时候二者没有特别的效果优劣</li>
</ul>
<h3 id="cart-classification-and-regression-tree">CART(Classification And Regression Tree)</h3>
<blockquote>
<p>scikit-learn的决策树实现：CART</p>
</blockquote>
<p><strong>复杂度</strong></p>
<ul>
<li>预测： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li>
<li>训练： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m*logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li>
<li>剪支： 降低复杂度，解决过拟合</li>
</ul>
<p><strong>超参数</strong></p>
<p>避免过拟合、欠拟合</p>
<ul>
<li>max_depth： 限制最大深度为2</li>
<li>min_samples_split： 至少要有多少个样本数据才继续拆分下去</li>
<li>min_samples_leaf： 对于叶子结点来说最少要有几个样本</li>
<li>max_leaf_nodes：最多有多少个叶子节点</li>
</ul>
<p>可以用网格搜素寻找合适的参数</p>
<h3 id="决策树解决回归问题">决策树解决回归问题</h3>
<h3 id="决策树的局限性">决策树的局限性</h3>
<ul>
<li>决策边界只能是横平竖直，不能倾斜</li>
<li>不能学习参数</li>
<li>对个别样本比较敏感，可能会很大影响决策树</li>
</ul>
<p>每天都汇报投了哪几个单位</p>
]]></content>
      <categories>
        <category>计算机理论基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>复试之C/C++系列问题</title>
    <url>/2020/04/02/26Pku-Interview-C/</url>
    <content><![CDATA[<h3 id="c-c-中为什么有引用">C/C++中为什么有引用</h3>
<p>C++之所以增加引用类型, 主要是把它作为函数参数,以扩充函数传递数据的功能。</p>
<p>引用是一个常量指针占四个字节，编译器在编译时对引用作了更严格的限制，与普通指针相比更加安全。详细见<a href="https://www.cnblogs.com/ronny/p/3662556.html">C++的那些事：你真的了解引用吗</a></p>
<a id="more"></a>
<h3 id="指针和引用的区别">指针和引用的区别</h3>
<p>（1）指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>
（2）指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）<br>
（3）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化<br>
（4）指针的值在初始化后可以改变，即指向其它的存储单元，而引用初始化后就不会再改变。<br>
（5）&quot;sizeof引用&quot;得到的是所指向的变量(对象)的大小，而&quot;sizeof指针&quot;得到的是指针本身的大小。<br>
（6）作为参数传递时，二者有本质不同：指针传参本质是值传递，被调函数的形参作为局部变量在栈中开辟内存以存放由主调函数放进来的实参值，从而形成实参的一个副本。而引用传递时，被调函数对形参的任何操作都会通过一个间接寻址的方式影响主调函数中的实参变量。</p>
<h3 id="指针数组-数组指针">指针数组、数组指针</h3>
<p>（1）指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。<br>
（2）数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[<span class="number">4</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;shannxi&quot;</span>, <span class="string">&quot;xian&quot;</span>&#125;; </span><br><span class="line"><span class="comment">//arr[4]是一个定义的数组。把它对应到对应到内存中，arr是一个在栈区,有四个元素的数组，而每一个元素又是一个指针，所以说它的四个元素各占四个字节，所以变量arr的大小是16个字节。arr+1会跳过四个字节。也就是一个指针的大小 。</span></span><br><span class="line"><span class="keyword">char</span> (*pa)[<span class="number">4</span>]; <span class="comment">//pa是一个指针指向一个char [4]的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="c-内存布局">C++内存布局</h3>
<p>（1）栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量值等，其操作方法类似数据结构中的栈。<br>
（2）堆区（heap）：一般由程序员分配释放，与数据结构中的堆毫无关系，分配方式类似于链表。<br>
（3）全局/静态区（static）：全局变量和静态变量的存储是放在一起的，在程序编译时分配。<br>
（4）文字常量区：存放常量字符串。<br>
（5）程序代码区：存放函数体（类的成员函数、全局函数）的二进制代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> s[]=<span class="string">&quot;bb&quot;</span>; <span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">	<span class="keyword">char</span> *p3=<span class="string">&quot;123&quot;</span>; <span class="comment">//其中，“123\0”常量区，p3在栈区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">0</span>; <span class="comment">//全局区</span></span><br><span class="line">	p1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">//10个字节区域在堆区</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p1,<span class="string">&quot;123&quot;</span>); <span class="comment">//&quot;123\0&quot;在常量区，编译器 可能 会优化为和p3的指向同一块区域</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h3 id="c-c-内存分配有三种方式：">C/C++内存分配有三种方式：</h3>
<p>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<br>
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。<br>
动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏。另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</p>
<h3 id="malloc-free-new-delete区别">malloc/free 、new/delete区别</h3>
<p>（1）malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>
（2）对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>
（3）C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br>
（4）new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。</p>
<h3 id="字节对齐问题">字节对齐问题</h3>
<p>字节对齐是C/C++编译器的一种技术手段，主要是在可接受空间浪费的前提下，尽可能地提高对相同元素过程的快速处理（比如32位系统，4字节对齐能使CPU访问速度提高）</p>
<p>字节对齐的原则</p>
<p>（1）结构体中每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会填充字节</p>
<p>（2）结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会填充字节。</p>
<h3 id="内联函数有什么优点？内联函数和宏定义的区别">内联函数有什么优点？内联函数和宏定义的区别</h3>
<p><strong>优点：</strong></p>
<p>函数会在它所调用的位置上展开。这么做可以消除函数调用和返回所带来的开销（寄存器存储和恢复），而且，由于编译器会把调用函数的代码和函数本身放在一起优化，所以也有进一步优化代码的可能。<br>
内联函数使用的场合：对于简短的函数并且调用次数比较多的情况，适合使用内联函数。</p>
<p>内联函数和宏定义区别：</p>
<p>1)<strong>内联函数在编译时展开，而宏在预编译时展开</strong><br>
2)在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。<br>
3)内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。<br>
4)宏不是函数，而inline是函数</p>
<p><strong>以下情况不宜使用内联：</strong></p>
<p>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</p>
<p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p>
<h3 id="覆盖-重载-隐藏的区别">覆盖、重载、隐藏的区别</h3>
<p>（1）重载：重载翻译自overload，是指同一可访问区内被声明的几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。<br>
（2）覆盖：重写翻译自override，是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致，只有函数体不同。</p>
<p>（3）重定义(隐藏)是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>
<ul>
<li>如果派生类的函数和基类的函数同名，但是参数不同，此时不管有无virtual，基类的函数被隐藏；</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时基类函数被隐藏。</li>
</ul>
<h3 id="虚函数有什么作用？">虚函数有什么作用？</h3>
<p>（1）虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现<strong>灵活扩展和多态性</strong>；</p>
<p>（2）如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，则否子类也是抽象类；</p>
<p>（3）含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类。</p>
<p>更详细的讲解见<a href="https://blog.csdn.net/haoel/article/details/1948051">C++虚函数表解析</a></p>
<h3 id="虚析构函数有什么作用？">虚析构函数有什么作用？</h3>
<p>（1）析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数；</p>
<p>（2）在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄漏；</p>
<p>（3）给基类一个虚析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部的派生类部分。</p>
<h3 id="构造函数与析构函数的异同点">构造函数与析构函数的异同点</h3>
<h4 id="构造函数特点">构造函数特点</h4>
<p>（1）构造函数的名字必须与类名相同；</p>
<p>（2）构造函数<strong>可以有任意类型的参数，但不能有返回类型</strong>；</p>
<p>（3）定义对象时，编译系统会自动调用构造函数；</p>
<p>（4）构造函数是<strong>特殊的成员函数</strong>，函数体可以在类体内也可以在类体外；</p>
<p>（5）构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的。</p>
<h4 id="析构函数特点">析构函数特点</h4>
<p>（1）析构函数的名字必须与类名相同，但它<strong>前面必须加一个波浪号</strong>；</p>
<p>（2）析构函数没有参数，也没有返回值，而且不能被重载，因此<strong>在一个类中只能有一个析构函数</strong>；</p>
<p>（3）当撤销对象时，编译系统会自动调用析构函数；</p>
<p>（4）析构函数<strong>可以是virtual</strong>，而<strong>构造函数不能是虚函数</strong>。</p>
<h3 id="成员函数和友元函数的区别">成员函数和友元函数的区别</h3>
<p>相同点：</p>
<ol>
<li>对类的存取方式相同，可以直接存取类的任何存取控制属性的成员</li>
<li>可以通过对象存取形参、函数体中该类类型对象的所有成员</li>
</ol>
<p>不同点：</p>
<ol>
<li>成员函数有this指针，而友元函数没有</li>
<li>友元函数不能被继承</li>
</ol>
<h3 id="vector迭代器的几种失效的情况"><strong>vector迭代器的几种失效的情况</strong></h3>
<p>1.当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。</p>
<p>2.当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操 作返回的迭代器都会失效。</p>
<p>3.当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。</p>
<h3 id="有哪些东西是编译期间确定的-哪些是运行期间确定的？">有哪些东西是编译期间确定的，哪些是运行期间确定的？</h3>
<p>考察编译和运行的了解。编译期间确定数组大小空间，宏定义，内联函数展开，extern变量等。运行期间确定new大小，多态类对象的函数调用，未赋值全局指针的指向等。</p>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/hsq1596753614/article/details/80249605">C/C++ 经典面试题总结</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲之行</title>
    <url>/2020/03/31/25Australia-Trip/</url>
    <content><![CDATA[<p><img src="/images/Australia.jpg" alt="cover"></p>
<a id="more"></a>
<p>距离开澳洲已经两个多月了，由于最近要交材料、做总结，才让我想起来还没有给这趟旅途画上一个完美的句号，让我沿着日志集再回忆一下</p>
<p>那是我第一次坐飞机，惊叹于那狭小的座椅提供给我丰富的功能，也是第一次感受飞机上升、下坠的不适感，让我难以忘怀。到了悉尼，还没下飞机就感受到那扑面而来的热风，果然跟书上写的一样，南半球的1月是夏天，我好奇的打量着周围的一切，看到了与我们国内相反的驾驶员位置、靠左行驶、过马路拍按钮等各种新鲜事。</p>
<p>第一周的生活是围绕<strong>International house</strong>和<strong>卧龙岗大学</strong>展开的，我们每天在Internation house吃饭(一天两顿)，到卧龙岗大学听课+参观。吃了将近一周的三明治，最后大家闻面包色变哈哈，并且那的菜经常是土豆和烤肉，偶尔还会有Spaghetti，没有筷子，都是刀叉，每天有水果有热饮，总的来说不算太糟糕(佩服常住的国人)。</p>
<p>至于听课内容，我觉得主要是在锻炼我们的听力和口语，内容不是很复杂，浅显易懂，还是挺适合我们的，Helen老师亲切友善，给个赞！另外我在交流学习的过程中，也感受到国外的课堂氛围，很轻松，老师同学互动频繁。同时也认识到了自己的局限与不足，从Belinda博士那里了解到我们<strong>不应该局限于工作本身</strong>，而是经常思考<strong>我们未来从事的工作如何能贡献世界</strong>。周五进行了Presentation，感觉很糟糕，虽然做了长时间，但稿子还是不熟练，磕磕绊绊，场面十分尴尬，不过Helen老师还是给了每个人不错的成绩，我意识到是我把成绩看的太重要了，而一定程度上忽略了在准备过程中的提升。</p>
<p><img src="/assets/1585663552586.png" alt="1585663552586"></p>
<p>每个人都获得了一份结业证书，如图</p>
<p>在周六日我们坐了轮渡，去了动物园，目睹了可爱的考拉和袋鼠的风采</p>
<p><img src="/assets/1585664083920.png" alt="1585664083920"></p>
<p>后来又去逛商场，看着一件件衣服也没标多少，可想想1：5的汇率就谨慎了很多哈哈，期间我疯狂的想办法冲上去跟店员chat，迫切的想提高自己的英语口语水平，事实情况就是问了一句之后，就疯狂点头然后撤(因为听不懂回了)，因为这个闹了不少笑话。</p>
<p>在整个旅途中，我不得不吐槽澳洲的饭店，多倒是挺多的，就是去哪都得用手抓(筷子、勺子、刀叉啥都没有)，而且坐的地方还很少，还得想尽办法给店员指想要的东西，那段时间我天天练英语口语来安慰自己。</p>
<p>第二周就丰富多了，先是住进了豪华总统套房，超大的客厅、超全的配置，简直是VIP的体验。</p>
<p><img src="assets/Australia_Room.jpg" alt=""></p>
<p>期间，我们参观了悉尼大学，看到了哈利波特取景的那栋大楼，真的是非常美了，参观了悉尼大学的图书馆、博物馆，看到了很多新颖的设计以及一些珍贵的文物。</p>
<p><img src="assets/Australia_Sydney.jpg" alt=""></p>
<p>此行是Elieen Zhang 老师给我们做介绍，她是悉尼大学的毕业生，在参观即将结束时，Elieen老师针对我们当前即将毕业的困惑谈了谈自己的经历和看法，真的是收益匪浅。</p>
<p>后来，我们又有幸见到了各行各业的大佬(包括owen老师)，他们讲述了自己创业的经历，有中国人也有外国人，让我或者说我们印象最深刻的还是Iron Fish的终极boss周华先生，他能给我们做演讲是大家都没有意料到的，他是俞敏洪的同窗室友，早些年放弃了翻译官的岗位来到澳洲从零开始，从小职员做起，一步一步创建了建立了自己的事业。</p>
<p>他简单给我们讲述了他的传奇经历，告诫我们人所赚到的钱和他给社会所带来的便利和服务是成正比的，我总结了出了以下几点</p>
<ul>
<li>有高的目标</li>
<li>思想开放，积极听取别人的意见，博采众长</li>
<li>做自己喜欢做的、擅长做的，做的事情要对别人有价值、对社会有价值</li>
</ul>
<p>多向优秀的人靠拢，他们对你的影响远远大于你的工资收入。</p>
<p>学校只是一个好的起点，不要盲目追求学历，学的越多越会分析事情为什么不可能发生，限制自己的想象。不要那么焦躁，把该学的东西学好了，在各个领域都会起到作用。还有就是<strong>要多看新闻、政治热点、要兴趣广泛，多谈别人感兴趣的，做一个专心的listener。不管做什么，即使是自己不喜欢的，但也一定把它做好，因为这些都是暂时的，这是一个好的习惯</strong>。选择比努力重要，走的越远偏离的方向越远，小刀磨得再锋利也不实用，要善于把握机遇。</p>
<p>一句座右铭送给大家<strong>有事做，有人爱，有所期待！</strong></p>
<p><img src="/assets/Australia_Speech.jpg" alt=""></p>
<p>在此次交流学习的最后，我们每个人进行了汇报，分享了此次交流学习的感想，认真的进行了自我反思，大家都有一定程度的提高，我也成长了不少，感谢李老师、owen老师和小姐姐一路上的照顾，感谢企业大亨们的分享，感谢学校精心的安排，相信我能走的更远！</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘学习笔记</title>
    <url>/2020/02/15/24DataMining/</url>
    <content><![CDATA[<p><img src="/images/data-mining.jpg" alt="cover"></p>
<a id="more"></a>
<blockquote>
<p>记笔记的方式，先听课程，然后回忆复述课程里的重要知识点及相关概念，将其写到笔记上，随后看PPT核对</p>
<p>通过这三轮的反复强化一定可以把知识学牢！</p>
</blockquote>
<p>数据挖掘在高校内没有对应的课程或者方向，它是一个融合了数学、统计学、计算机、以及各领域知识的综/合性方向，它涵盖范围很广，遍及互联网的各个角落。它能够实现”数据-&gt;信息-&gt;知识-&gt;决策支持“的转变。</p>
<h2 id="走进数据科学">走进数据科学</h2>
<p>相关资料<a href="/download/Introduction.pptx">点击下载</a></p>
<p><img src="/assets/1581220990738.png" alt="1581220990738"></p>
<h3 id="大数据的三个特征">大数据的三个特征</h3>
<ul>
<li>高容量：从TB到ZB</li>
<li>多样性：从结构化数据到结构与非结构数据的混合</li>
<li>高速度：从批处理到如今的实时流数据处理</li>
</ul>
<h3 id="应用领域">应用领域</h3>
<ul>
<li>公共安全：美国各地区犯罪预测</li>
<li>健康医疗：根部人不同的DNA开出个性化药方</li>
<li>城市规划：哪些地方是人口密集区、交通、市场如何部署</li>
<li>零售行业：针对性广告投放</li>
<li>运动：美国小棒球社如何挑选潜力球员</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>交叉验证：将数据分为训练集和测试集</li>
<li>混淆矩阵：分为TP(True Positive)、FP(False Positive)、FT和TN，用来评估模型准确率</li>
<li>ROC曲线：AUC是ROC曲线与x轴围成的面积，用来评估模型的准确率</li>
</ul>
<p><img src="/assets/1581221686688.png" alt="1581221686688"></p>
<h2 id="数据预处理">数据预处理</h2>
<p>缺失值处理-----&gt;重复值处理-----&gt;类型转换与采样-----&gt;数据描述与可视化</p>
<h3 id="异常值与重复值检测">异常值与重复值检测</h3>
<p>数据缺失的原因</p>
<ul>
<li>设备故障</li>
<li>隐私数据没有提供</li>
<li>数据不适用</li>
</ul>
<p>数据缺失的种类</p>
<ul>
<li>完全随机的缺失</li>
<li>跟属性相关的缺失</li>
<li>不是随机的缺失</li>
</ul>
<p><strong>离群点（Outliers）</strong>：跟整体数据差异比较大</p>
<p><strong>异常点（Anomaly）</strong>：数据由于某种特定的原因导致异常</p>
<p><strong>LOF（Local Outlier Factor）</strong>：离群点检测算法</p>
<p>当一个点距离周围的点越近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lrd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>的值就会越大，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lrd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>的分母相当于平均距离。</p>
<p><img src="/assets/1582771321867.png" alt="1582771321867"></p>
<p>LOF的值表示的是相对距离的概念，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>r</mi><mi>d</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lrd(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>远大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>r</mi><mi>d</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lrd(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span>就说明A的近邻B到它附近的点的距离远小于A到它近邻的距离，那么就是表明A是一个离群点了。LOF值越大表明是离群点可能越大</p>
<p><strong>重复数据（Duplicate Data）</strong>：不同统计方式的列名不同、统计方式不同、存储方式也可能不同，但是统计的都是同类数据，解决方法是先排序(需要根据背景知识用key排序)再用滑动窗口进行比较去重。</p>
<h3 id="类型转换与采样">类型转换与采样</h3>
<p>对于某个属性的不同类别，不能采用简单的012的方式进行编码，因为这改变了不同属性之间的距离，从而可能改变问题复杂度。例子如下</p>
<p><img src="/assets/1582773085533.png" alt="1582773085533"></p>
<p>仅仅是将绿色和蓝色交换了位置，分界线就从两条曲线变成了两条直线，问题求解的方式就发生了改变。</p>
<p>因此在处理这些数据时，往往采用one-hot独热编码，解决了分类器不好处理属性数据的问题，让特征之间的距离计算更加合理</p>
<p><strong>One-Hot和word2vec</strong></p>
<p>One-Hot</p>
<ul>
<li>优点：一是解决了分类器不好处理离散数据的问题，二是在一定程度上也起到了扩充特征的作用</li>
<li>缺点：在文本特征表示上有些缺点就非常突出了。首先，它是一个词袋模型，不考虑词与词之间的顺序（文本中词的顺序信息也是很重要的）；其次，它假设词与词相互独立（在大多数情况下，词与词是相互影响的）；最后，它得到的特征是离散稀疏的</li>
</ul>
<p>word2vec</p>
<p>**采样的原因：**1.数据量非常大计算机处理不过来   2.没有办法得到完整的用户数据</p>
<p>采样的优点：能够用于调整类别比例，例如理工科男女比例，如果采用完整数据集，则明显男生比例很高，不利于模型处理</p>
<p>**不平衡数据：**不同类别的样本数相差较大，尽管分类器A的准确率高，但是其误判了很重要的5%的数据，并不合理</p>
<p><img src="/assets/1582773995499.png" alt="1582773995499"></p>
<p>解决办法</p>
<ul>
<li>扩充数据集</li>
<li>对数据集进行重采样，包括过采样和欠采样</li>
<li>改变分类算法</li>
<li>改变评价指标，如PR曲线</li>
</ul>
<p>在实际中可以采用除了Acc以外的其它的度量方式如G-mean、F-measure、Recall等等</p>
<p><strong>边缘采样</strong>：对于几百万的数据，其中有很多数据都是作用不大的，提取其中的边缘点进行计算更有价值，能够节约计算资源</p>
<h3 id="数据描述与可视化">数据描述与可视化</h3>
<p>Norlization：Min-max norlization、Z-score</p>
<p><strong>数据描述</strong>：平均值、中位数、变化程序</p>
<p><strong>数据可视化</strong>：一维数据直方图、二位数据坐标系、三维数据三维坐标系、高维数据Parallel<br>
Coordinates</p>
<h3 id="特征选择">特征选择</h3>
<p>从多个属性中，找出与问题有一定关联性的属性。</p>
<p><strong>信息增益</strong></p>
<p>怎么评价属性好不好？</p>
<p>答：查看该属性对结果的区分度，用熵Entropy衡量</p>
<p>信息增益ID3（Information gain）越大属性越好，表示它的跟结果越有关联，通常应用在决策树中</p>
<p><strong>特征子集搜索</strong></p>
<p><img src="/assets/1585473917480.png" alt="1585473917480"></p>
<p><strong>优化算法</strong></p>
<ul>
<li>模拟退火</li>
<li>禁忌搜索</li>
<li>遗传算法</li>
</ul>
<h3 id="特征提取">特征提取</h3>
<p><strong>特征选择和特征提取的区别</strong></p>
<p><strong>特征提取</strong>的方法主要是通过属性间的关系，如<strong>组合</strong>不同的属性<strong>得到</strong>新的属性，这样就<strong>改变</strong>了原来的特征空间。<br>
<strong>特征选择</strong>的方法是从原始特征数据集中<strong>选择</strong>出子集，是一种<strong>包含</strong>的关系，<strong>没有</strong>更改原始的特征空间。</p>
<p><strong>PCA（Principal Component Analysis）</strong></p>
<p>无监督学习，不考虑label，将高维数据降维，将其投影到可以分类的方向上（可以通过坐标旋转），数据在该方向上分布越分散越好</p>
<p>将样本点到投影线的距离表示成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>越小表明从高维投影到低维损失的信息越少</p>
<p>因此对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>使用拉格朗日乘数法，最后发现要最大化的值就是特征值</p>
<p>描述：将数据的协方差矩阵（covariance matrix）进行特征分解，找到特征值最大的特征向量上，投影到该方向上即可在满足最少损失的条件下，将数据降维到n-1、n-2、…、2、1维</p>
<p><strong>LDA（Linear Discriminant Analysis）</strong></p>
<p>针对有标签数据，基本思路也是降维，但是要保留的是类的区分属性。LDA在投影时的思想类似于PCA，都是进行坐标旋转，并使得目标函数最大</p>
<p>目标：令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>最大化</p>
<p><img src="/assets/1582795035267.png" alt="1582795035267"></p>
<p><strong>LDA和PCA例子</strong></p>
<p><img src="/assets/1582795709134.png" alt="1582795709134"></p>
<p><strong>LDA的缺点</strong></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">S_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可能是奇异矩阵，即行数不等于列数时，逆矩阵不存在</li>
<li>当不同类的中心点重合时，目标函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>为0，不work</li>
</ul>
<h2 id="从贝叶斯到决策树">从贝叶斯到决策树</h2>
<p><a href="NB-DT.pptx">课件下载</a></p>
<h3 id="监督学习">监督学习</h3>
<p>一种从数据推测函数的技术，输入是一系列的特征，输出是一个bool值(二分类)或者整数(多分类)</p>
<h3 id="贝叶斯分类-naive-bayes-classifier">贝叶斯分类(Naive Bayes Classifier)</h3>
<p>一些贝叶斯应用实例</p>
<p><strong>癌症</strong>：人群中检测出得癌症的概率是千分之八，人们往往容易产生恐慌</p>
<p>而从贝叶斯的角度分析，在得癌症的人群中假阳性的概率远大于真正癌症阳性的概率</p>
<p>这意味着即使体检报告上说得了癌症阳性，但其实上只有百分之20的概率是阳性。</p>
<p><strong>头疼和流感</strong>：不同的先验概率得到的结果不同</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">H=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>“Having a headache”           <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">F=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>“Coming down with flu”</p>
<p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>10</mn><mo separator="true">;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>40</mn><mo separator="true">;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P(H)=1/10;  P(F)=1/40;   P(H|F)=1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，这意味着患流感人中有50%会头疼，这听起来不可思议。</p>
<p>但从另一个角度来看头疼的人中只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">1/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">8</span></span></span></span>的人患了流感，而现实人们往往将其混为一谈，误以为头疼有50%是得了流感</p>
<p><strong>贝叶斯公式</strong></p>
<p>​							$  P(A|B)=\frac{P(B|A)P(A)}{P(B)} $</p>
<p><strong>朴素贝叶斯</strong></p>
<p>在贝叶斯公式基础上assumpt各个事件是<strong>条件独立</strong>的</p>
<p>​             				$ P (A,B|G) = P(A|G)P(B|G)          \leftrightarrows                       P(A|G,B) = P(A|G)$</p>
<p>在实际中的例子</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>r</mi><mtext>│</mtext><mi>M</mi><mi>a</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>S</mi><mi>m</mi><mi>o</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi>m</mi><mi>o</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(Cancer│Male,Smoking)=P(Cancer|Smoking)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">│</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></p>
<p>即抽烟男性得肺癌得概率等于抽烟者得肺癌的概率，跟性别无关</p>
<p><strong>肺癌</strong></p>
<p><strong>应用领域</strong></p>
<p>文本分类，提取文本中的关键词，作为分类属性，使用贝叶斯分类器计算不同用户感兴趣的类别</p>
<p>在提取文本关键词时，并不是将文本简单分成词，随后将每一组词都参与运算，这样计算量很大并且效果也不明显，可以提取文章中出现最多的词语来为文章分类标签，那么就只需要统计每个词的频率，简化了公式，也就能够构建词袋模型，每个用户都会有自己的词袋，里面装满了用户的阅读喜好</p>
<p><img src="/assets/1581422114618.png" alt="1581422114618"></p>
<h3 id="决策树">决策树</h3>
<p>决策树的优点是<strong>可解释性好</strong>，侯选属性在决策树中可以使用多次</p>
<p>决策树中建树的基本规则：信息增益大的属性应放在上层</p>
<p>当<strong>当前数据子集的标签一致</strong>、<strong>没有更多可用属性</strong>以及<strong>当前数据子集为空</strong>时必须停止树的增长</p>
<p>决策树剪支从<strong>叶节点</strong>开始</p>
<p>一些基本概念：</p>
<ul>
<li>
<p>熵(Entropy)：最大值是1，熵越大表示越难分类，即分类更倾向于靠猜</p>
<p>​					 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mo>∑</mo><msub><mi>p</mi><mi>i</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Entropy(S) = -\sum p_ilog(p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>信息增益(Information Gain)：表示经过分类后对熵的优化程度，值越大表示效果越好，每次选取信息增益最大的分类属性作为根节点，以此类推。但当Information Gain接近于1时表明该属性将每个样本都分成一个类别，容易出现过拟合。</p>
<p>​					<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \vline at position 32: …y(S)-\sum\frac{\̲v̲l̲i̲n̲e̲ ̲S_V\vline}{\vli…'>Gain(S,A)=Entropy(S)-\sum\frac{\vline S_V\vline}{\vline S\vline}Entropy(S_v)</span></p>
</li>
<li>
<p>奥卡姆的剃刀：如无必要，勿增实体，常用于两种或两种以上假说的取舍上，如果对于同一现象有两种或多种不同的假说，我们应该采取比较简单或可证伪的那一种，世界客观存在即是建立在客观实践之上，正所谓<strong>实践是检验真理的唯一标准</strong></p>
</li>
<li>
<p>过拟合：训练集效果好，可是测试集效果差</p>
</li>
</ul>
<p><strong>ID3决策树</strong></p>
<p>ID3是比较早期的一种决策树算法，分别对样本的所有属性计算信息增益， 找出信息增益最大的属性作为结点，并将该属性从候选属性中去除，以此类推最终得到一颗决策树。</p>
<p>但是ID3的缺点也比较明显，当Information Gain每次都接近于1时，很容易造成过拟合，即某个属性将单个样本分到一个个叶节点，这对新来的样本不能进行有效的预测。因此人们在此基础上进行了改进，出现了C4.5</p>
<p><strong>C4.5决策树</strong></p>
<p>C4.5算法不直接使用信息增益作为划分样本的主要依据，而是提出了另外一个概念————增益率，它在信息增益的基础上加入了惩罚项Penalized</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><mi>I</mi><mi>V</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">Gainratio(D,a) = \frac{Gain(D,a)}{IV(a)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \vline at position 26: …m_{v=1}^V\frac{\̲v̲l̲i̲n̲e̲ ̲D^v\vline}{\vli…'>IV(A)=-\sum_{v=1}^V\frac{\vline D^v\vline}{\vline D\vline}log_2\frac{\vline D^v\vline}{\vline D\vline}</span></p>
<p>但是同样的这个增益率对可取值数目较少的属性有所偏好，因此C4.5决策树先从候选划分属性中找出信息增益高于平均水平的属性，在从中选择增益率最高的。</p>
<p><strong>CART决策树</strong></p>
<p>CART决策树的全称为Classification and Regression Tree,可以应用于分类和回归。采用基尼系数来划分属性</p>
<p>基尼值</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \vline at position 21: …D)=\sum_{k=1}^{\̲v̲l̲i̲n̲e̲ ̲y\vline}\sum_{k…'>Gini(D)=\sum_{k=1}^{\vline y\vline}\sum_{k&#039;}p_kp_{k&#039;}=1-\sum_{k=1}^{\vline y\vline}p_k^2</span></p>
<p>基尼系数</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \vline at position 37: …{v=1}^{V}\frac{\̲v̲l̲i̲n̲e̲ ̲D^v\vline}{\vli…'>GiniIndex (D,a)=\sum_{v=1}^{V}\frac{\vline D^v\vline}{\vline D\vline}Gini(D^v)</span></p>
<p>因此在候选属性中选择基尼系数最小的属性作为最优划分属性。</p>
<p><strong>剪支</strong></p>
<p>树不能太复杂了，会过学习，当然也不能太简单了，否则不足以描述数据的分布</p>
<p>决策树数据集三个部分：训练集、训练集、验证集(validation set)</p>
<p>剪一点看一点盯着验证集的误差，在拐点的地方收手，不能再减了</p>
<p><strong>连续型属性（Continuous Attributes）</strong></p>
<p>取阈值进行离散化，阈值一般都出现在结果发生变化的地方</p>
<p>如何取阈值，还要用信息增益评估</p>
<p>扩展阅读<a href="https://blog.csdn.net/jiaoyangwm/article/details/79525237">https://blog.csdn.net/jiaoyangwm/article/details/79525237</a></p>
<h2 id="神经网络"><strong>神经</strong>网络</h2>
<p><a href="39.106.111.188/download/Neural_Networks.pptx">课件下载</a></p>
<h3 id="感知机">感知机</h3>
<p>无法解决线性不可分问题</p>
<p><strong>梯度下降（Gradient Descent）</strong></p>
<p>误差沿着每次梯度的方向移动，从而不断调整权重大小，最终能找到解决问题的最佳权重组合</p>
<p><img src="/assets/1582970841376.png" alt="1582970841376"></p>
<p>图中学习率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">η</span></span></span></span>限制权重调整的快慢，通常取0.001。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">t_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表期望输出，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">O_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示实际输出。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>则是为了便于平方求导消掉。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>W</mi><mi>i</mi></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Delta W_i&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>则是由于要减小误差，要使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不断向误差减小的方向调整</p>
<p><strong>Delta Rule公式</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><mi>η</mi><msub><mo>∑</mo><mrow><mi>d</mi><mo>∈</mo><mi>D</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mi>d</mi></msub><mo>−</mo><msub><mi>o</mi><mi>d</mi></msub><mo stretchy="false">)</mo><msub><mi>x</mi><mrow><mi>i</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta W_i = \eta \sum_{d\in D}(t_d - o_d)x_{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18639799999999984em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>当期望输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>d</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_d=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">o_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>没有那么大，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>d</mi></msub><mo>−</mo><msub><mi>o</mi><mi>d</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_d-o_d&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Delta W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>同号，这意味着当输入一个正数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>时，权重会增加，进而增大输出，进而使实际输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">o_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">t_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><strong>batch learning</strong></p>
<p>在batch learning模式下，权重调整出现在学习一批样本之后，即将每个样本的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Delta w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>累加起来，最终再修改<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><strong>stochastic learning</strong></p>
<p>知错就改，每个样本都会更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<h3 id="多层感知机">多层感知机</h3>
<p>可以解决线性不可分问题，如XOR，原理是将原始问题在隐含层映射成线性可分问题</p>
<p><img src="/assets/1582972473943.png" alt="1582972473943"></p>
<p><strong>Sigmoid函数</strong></p>
<p><img src="/assets/1582972522129.png" alt="1582972522129"></p>
<h3 id="bp反向传播">BP反向传播</h3>
<p><strong>对输出层权重的调整</strong></p>
<p><img src="/assets/1582972912130.png" alt="1582972912130"></p>
<p>BP算法在误差对输入求偏导的过程同感知机基本一致，唯一不同的是不在假设输出等于输入，而是更换了激活函数sigmoid。由于隐含层不知道期望输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">t_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>因此不能直接套。</p>
<p><strong>输入对隐含层的误差分析</strong></p>
<p>采用反向传播的方式，从输出层倒着向输入层过过渡</p>
<p><img src="/assets/1582973246391.png" alt="1582973246391"></p>
<p>从图中可以看到，隐含层的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个神经元的权重修改量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><msub><mi>w</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta w_{ji}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是由它指向的各个输出的权重加权和</p>
<p><strong>延伸</strong></p>
<p>BP算法是一种更新权重的方法，容易掉到局部最优点，解决方案从不同的起始点出发。</p>
<p>在权重更新公式中引入冲量有助于摆脱平缓区域</p>
<p>Elman Network：第T时刻网络的输出取决于当前的网络输入和第T-1时刻网络的内部状态</p>
<p>Hopfield Network：在一定程度上模拟人脑的联想记忆功能，是<strong>基于内容的检索</strong>，含噪声的模式识别</p>
<h2 id="支持向量机">支持向量机</h2>
<p><a href="39.106.111.188/download/Support_Vector_Machines.ppdx">资源下载</a></p>
<p>线性SVM</p>
<p>线性分类器</p>
<p>支持向量(support vector):确定了分界面可以平移范围的数据点，margin越大容错能力越强</p>
<p>超平面<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">w*x+b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的margin大小为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \vline at position 10: \frac{2}{\̲v̲l̲i̲n̲e̲ ̲w\vline}'>\frac{2}{\vline w\vline}</span></p>
<p><img src="/assets/1581757370434.png" alt="1581757370434"></p>
<p>Soft Margin:有些点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo>≱</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">wx+b\not\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即噪声点使得无法优化margin，于是放宽条件，在求解时加入了惩罚量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span></p>
<p>但在实际推倒之后发现目标函数(objective function)并没有发生很大变化。</p>
<h3 id="非线性svm">非线性SVM</h3>
<p>映射到feature space，高维空间得特点是容易分类，可是问题在于计算量很大</p>
<p><img src="/assets/1581760041535.png" alt="1581760041535"></p>
<p>kernel trick：利用向量的特性，将高维空间得计算与低维空间得计算等价，巧妙地绕开了高维空间的计算</p>
<p>String Kernel：专门处理字符串的和函数</p>
<h3 id="发展过程">发展过程</h3>
<p><img src="/assets/1581765589562.png" alt="1581765589562"></p>
<ul>
<li><strong>VC Dimension</strong></li>
</ul>
<p>一个分类模型的Capacity是指不论怎么分配标签，都能将多少个点分开，也就是VC Dimension</p>
<p><a href="39.106.111.188/download/SVM_Explained.pdf">拓展</a></p>
<h2 id="聚类分析">聚类分析</h2>
<p>一个好的聚类算法能够<strong>处理非球形的数据分布</strong>、<strong>能够处理噪点和离群点</strong>、<strong>对样本输入序列不敏感</strong>、<strong>对海量数据的可扩展性</strong></p>
<p>分割聚类(Partitioning Methods)</p>
<p>K-means</p>
<p>Sequential Leader Cluster:处理流数据，迭代一次，不需要初始k</p>
<p>层次聚类(Hierarchial  Methods)</p>
<p>EM算法：Model Para和latent Para，迭代收敛求模型参数</p>
<h3 id="density-based-methods">Density Based Methods</h3>
<p><strong>DBSCAN</strong></p>
<h3 id="hierarchical-clustering"><strong>Hierarchical Clustering</strong></h3>
<p>Agglomerative Methods</p>
<h2 id="推荐算法">推荐算法</h2>
<p>PageRank：在Googlez中用的比较多，评价网页重要性的指标</p>
<h3 id="协同过滤-collaborative-filtering">协同过滤(Collaborative Filtering)</h3>
<p><strong>Memory-Based CF</strong>：求不同用户或者商品的相似性来预测分数</p>
<p><strong>Model-Based CF</strong>：将问题转化为分类问题，例如Naive classifier</p>
<p>三个经常遇到的问题</p>
<ul>
<li>Gray Shape：兴趣跟别人不一样，找不到类似的参考</li>
<li>Shilling Attack：恶意好评或者坏评，水军</li>
<li>Cold start：一个新用户或者新商品往往还没有数据难以打分</li>
</ul>
<p>求不同用户的相关性系数，求出用户对某商品的评分，进而进行适当推荐</p>
<p>也可以从不同的商品的相关性考虑，进而得到不同商品之间的关系</p>
<p><strong>TF-IDF的机理</strong></p>
<h2 id="集成学习">集成学习</h2>
<p>集成学习是按照一定策略的将不同的模型组合到一起，从而能更好的解决机器学习问题。</p>
<p>集成学习是一类算法的统称，包含Bagging和Boosting，这两类各自又包含了很多的算法。</p>
<p>集成学习主要解决两个问题：</p>
<ol>
<li>单个模型效果不佳</li>
<li>解决多个模型的Model Selection问题</li>
</ol>
<p>集成学习在机器学习中的位置</p>
<p><img src="/assets/1582511583363.png" alt="1582511583363"></p>
<p><strong>Divide and Conquer</strong></p>
<p>集成学习可以将复杂问题简化为多个简单分类问题，来求的近似解，即分而治之。</p>
<h3 id="bagging">Bagging</h3>
<p><strong>Majority Voting</strong>：统计不同分类器的投票结果，选出票数最多的结果作为最终answer</p>
<p><strong>Weighted Majority Voting</strong>：按照权重投票，不同的分类器的效果不一样，选择加权最大的类别作为answer</p>
<p><strong>Diversity</strong>：Bagging的前提是各个分类器都不同，不同主要包含三个方面</p>
<ul>
<li>
<p>不同的训练算法：SVM、LinearRegression、DeepLearning等等</p>
</li>
<li>
<p>不同的训练过程：1.不同的初始参数   2.不同的训练集   3.不同的Feature Selection</p>
</li>
</ul>
<p><strong>Bootstrap Samples</strong>：随机抽样，有放回的随机抽取</p>
<p><strong>Bagging的思想</strong>：Bootstrap Aggregation，对不同的分类器进行Majority Voting</p>
<p><strong>Ramdom Forest</strong></p>
<p>随机森林算法是Bagging的一种，这个森林是由多颗决策树构成的，并且这些决策树互不相同。为了保证生成不同的决策树，随机森林算法进行了以下的处理</p>
<ul>
<li>Bootstrap Samples：随机抽样，选取一部分数据集</li>
<li>Ramdom Feature Selection：随机选区一定数量的特征</li>
</ul>
<p>因此随机森林的优点也很明显</p>
<ul>
<li>随机森林的Cross-Validation不再是传统的divide，而是将随机抽样中一次都没有被选中的样本Out of Bag（大概1/3）作为测试集</li>
<li>随机森林巧妙地化解了特征选择问题、过拟合问题</li>
<li>随机森林支持分类和回归问题，只有少量的参数，却有很高的Accuracy</li>
</ul>
<h3 id="boosting">Boosting</h3>
<p><strong>Stacking</strong>：bagging升级版，其工作过程如下图所示，在原有基础分类器上增加了权重，这些权重通过训练器C的训练进行调节，最终利用权重和来决策最终结果。</p>
<p><img src="/assets/1582517309628.png" alt="1582517309628"></p>
<p><strong>Boosting思想</strong>：串行训练分类器，对样本引入了权重。当前面的分类器总是将一个样本分错的时候，其权重就会越来越大，那么最新的分类器总是着重训练这些权重较大的样本，从而提高算法的accuracy。下面是boosting的一些特点</p>
<ul>
<li>分类器串行生成</li>
<li>集中训练权重较大的数据点</li>
<li>输出结合权重进行投票</li>
<li>可以通过多个弱分类器（accuracy&gt;50%）来训练出强分类器</li>
</ul>
<p><strong>boosting算法流程</strong></p>
<p><img src="/assets/1582517747859.png" alt="1582517747859"></p>
<p><strong>AdaBoost</strong></p>
<p>数据挖掘十大算法之一，运用了boosting的思想，每次分类后对样本权重进行调节，输出不同准确率加权和。<br>
如下如是一个Demo演示训练过程，第一个分类器分出了两个，分错了四个，那么下一次就会在第一个分错的基础上进行二次分类，以此类推，最终得到黑色的不规则图形，完美的将数据分开。可以看出多个弱分类器是完全可以生成一个强分类器的。</p>
<p><img src="/assets/1582517968500.png" alt="1582517968500"></p>
<p>公式推导过程：详见<a href="39.106.111.188/download/Ensemble_Learning.pptx">集成学习</a></p>
<p><strong>优点：</strong></p>
<ul>
<li>简单容易使用</li>
<li>几乎没有需要调整的参数</li>
<li>训练集可证明误差边界</li>
<li>不会出现过拟合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每次选则的不是最优的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> ，只是采用贪心策略取的近似值</li>
<li>不能根据测试样本进行自适应调整</li>
<li>对噪声比较敏感</li>
</ul>
<p><strong>固定权重和动态权重：</strong></p>
<p>在adaboost中各个样本的权重都是固定的，不会根据输入发生变化，但是实际上有些模型对样本的估计结果并不好。在ReginBoost中引入了动态权重，解决了这个问题</p>
<p><strong>ReginBoost</strong></p>
<p>在基础分类器之上添加置信度的预测器，该置信度预测器实际上采用了k近邻的方式评估置信度</p>
<p><img src="/assets/1582536785047.png" alt="1582536785047"></p>
<p>对比RegionBoost和Adaboost的训练效果，如下图，左侧为训练误差，右侧为测试误差</p>
<p><img src="/assets/1582536927758.png" alt="1582536927758"></p>
<p>很明显可以看到尽管Adaboost的训练误差比较小，最后甚至趋于0，但是其测试误差很大，也就是说它预测的并不可靠。而相反ReginBoost虽然训练误差最终趋于平缓，但是其测试误差越来越小，这才是我们需要的模型。</p>
<h2 id="进化计算">进化计算</h2>
<h3 id="全局优化">全局优化</h3>
<p><strong>旅行商问题（tsp）</strong></p>
<p>假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。</p>
<p>关键概念</p>
<ul>
<li>基于人口的随机优化算法</li>
<li>内在并行，不容易陷入局部最优点</li>
</ul>
<p>经典算法</p>
<ul>
<li>
<p><strong>GA：Genetic Algorithm</strong></p>
</li>
<li>
<p><strong>GP：Genetic Proramming</strong></p>
</li>
<li>
<p>ES：Evolution Strategies</p>
</li>
<li>
<p>EP：Evoluntionary Programming</p>
</li>
<li>
<p>EDA：Estimation of Distribution Algorithm</p>
</li>
<li>
<p>PSO：Particle Swarm Optimization</p>
</li>
<li>
<p>ACO：Ant Colony Optimization</p>
</li>
<li>
<p>DE：Differencial Evoluntion</p>
</li>
</ul>
<p><strong>并行搜索：</strong></p>
<h3 id="遗传算法-genetic-algorithms">遗传算法(Genetic Algorithms)</h3>
<p>每个问题的解决方案表示为染色体向量，初始随机生成多个染色体，然后一代代发生进化，基于自然进化的方式一代代进行改良。主要包含以下三方面的内容</p>
<ol>
<li>
<p><strong>表示</strong></p>
<ul>
<li>Individual（chromesome）</li>
<li>Population：a set of individuals</li>
<li>Offspring：通过基因生成器生成的individuals</li>
<li>Encoding：Binary Or Gray</li>
</ul>
</li>
<li>
<p><strong>生成基因</strong></p>
<ul>
<li>杂交：在两个染色体之间交换遗传物质</li>
<li>变异：随机修改选定位置的基因值</li>
</ul>
</li>
<li>
<p><strong>选择</strong></p>
<ul>
<li>Roulette Wheel Selection：轮盘选择法，就是通过丢飞镖选择性状，值越大概率越大，缺点是没法处理负值或有单个值特别高就会漏选较好的变异体</li>
<li>Rank Selection：利用排名减小值的差距</li>
<li>Tournament Selection：两个或多个人相互PK，人数越多presure越大</li>
<li>Elitism Selection：精英选择，后代不一定比双亲好，可能由于变异或者杂交损失一些染色体，复制最好的性状到下一代。</li>
<li>Offspring Selection：用最老的染色体代替子孙染色体</li>
</ul>
</li>
</ol>
<p><strong>选择VS杂交VS变异</strong></p>
<ul>
<li>选择
<ul>
<li>可视为搜索资源分配的调节机制</li>
<li>进化初期Selection Pressure过大易导致不成熟收敛</li>
</ul>
</li>
<li>杂交
<ul>
<li>从好的个体基因生成更好的个体</li>
<li>是GA的主要搜索方式</li>
<li>体现出对现有搜索结果的精细利用（Exploitation）</li>
<li>不影响基因的多样性</li>
</ul>
</li>
<li>变异
<ul>
<li>增加基因多样性</li>
<li>体现出对解空间的各个区域的探索（Exploration）</li>
<li>通常独立作用于个体的某一位基因</li>
</ul>
</li>
</ul>
<p>上述过程总的来说是Exploration vs. Exploitation，前者意为探险，即探索不同的区域，主要从基因多样性角度考虑，后者Exploitation则指在某个区域进行更深层次的勘探（Choice）</p>
<p><strong>GA 框架</strong></p>
<p><img src="/assets/1582683540858.png" alt="1582683540858"></p>
<h3 id="遗传编程-genetic-programming">遗传编程(Genetic Programming)</h3>
<h3 id="可进化硬件-evolvable-things">可进化硬件(Evolvable Things)</h3>
]]></content>
      <categories>
        <category>计算机理论基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署博客到云服务器ECS</title>
    <url>/2020/02/07/23DeployToECS/</url>
    <content><![CDATA[<p><img src="/images/aliyunPlan.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="前言：">前言：</h2>
<p>在新型肺炎盛极一时的寒假，只能呆在家里，所以可不能一直堕落下去，否则就浪费太多时间了。正好这会各个机构都尽其所能提供<strong>免费</strong>资源，还有免费6个月的阿里云服务器可以用(详见<a href="https://developer.aliyun.com/adc/student/">阿里云高校学生“在家实践计划”</a>)，还不赶紧趁这个机会好好冲冲电！</p>
<p>租了服务器可以用来运行一些网站，应用还有一些小工具，还可以做内网穿透，总之极大的方便了与其他同学的分享和交流，所以决定先把我本地的hexo部署到服务器上(原先部署在github上)。</p>
<h2 id="本地环境">本地环境</h2>
<p>要有hexo,node.js,git，详情见<a href="http://39.106.111.188/2018/08/07/02Blog-Build/">第一次建网站</a></p>
<h2 id="服务器端">服务器端</h2>
<p>需要一台服务器，这里用的是阿里云的ECS ubuntu 18.04.1，能够正常登陆实例</p>
<h2 id="安装git和nginx">安装Git和Nginx</h2>
<p>git用于版本管理和部署，Nginx用于静态博客托管</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git nginx -y</span><br></pre></td></tr></table></figure>
<h2 id="配置ssh">配置SSH</h2>
<p>将本地公钥复制，一般在(C:\Users\Administrator\.ssh)下，如果没有的话，在git bash中用<code>ssh-ken -t rsa</code>生成ssh公钥</p>
<p><img src="/assets/1581063553702.png" alt="1581063553702"></p>
<ul>
<li>在云服务器上创建一个git用户，用来运行git服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser git #创建用户</span><br><span class="line">passwd git  #设置密码</span><br></pre></td></tr></table></figure>
<ul>
<li>切换至git用户，添加SSH Key</li>
</ul>
<p>在服务器端，切换至刚刚创建好的git用户下，创建<code>.ssh文件</code>和<code>authorized_keys</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~&#x2F;.ssh</span><br><span class="line">vim ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>
<ul>
<li>修改权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">chmod 600 .ssh&#x2F;authorzied_keys # 将文件设置为可读可写</span><br><span class="line">chmod 700 .ssh #将该文件夹设置为可读可写可执行，注意文件夹的可执行是指能访问</span><br></pre></td></tr></table></figure>
<ul>
<li>测试git连接</li>
</ul>
<p>切换到本地机器上，在本地机器上测试是否能连接到你的远程git用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -v git@SERVER_IP   #你的服务器IP</span><br></pre></td></tr></table></figure>
<p>测试成功（中间可能让输入密码，不要慌就是你的git user的密码或者试试远程）</p>
<p><img src="/assets/1581064070477.png" alt="1581064070477"></p>
<h2 id="创建git仓库">创建Git仓库</h2>
<p>在<code>/var/repo/</code>下创建名为hexo_website的裸仓库。用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir &#x2F;var&#x2F;repo&#x2F;   #创建目录</span><br><span class="line">sudo chown -R $USER:$USER &#x2F;var&#x2F;repo&#x2F;  #文件拥有着</span><br><span class="line">sudo chmod -R 755 &#x2F;var&#x2F;repo&#x2F;	#可读可写可执行</span><br><span class="line"> </span><br><span class="line">cd &#x2F;var&#x2F;repo&#x2F; </span><br><span class="line">git init --bare hexo_static.git  #初始化仓库</span><br></pre></td></tr></table></figure>
<h2 id="配置nginx托管文件目录">配置Nginx托管文件目录</h2>
<p>创建<code>/var/www/hexo</code>目录，用于Nginx托管，修改目录所有权和权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;var&#x2F;www&#x2F;hexo</span><br><span class="line"></span><br><span class="line">sudo chown -R $USER:$USER &#x2F;var&#x2F;www&#x2F;hexo</span><br><span class="line">sudo chmod -R 755 &#x2F;var&#x2F;www&#x2F;hexo</span><br></pre></td></tr></table></figure>
<p>随后修改Nginx的<code>default</code>设置，使<code>root</code>指向<code>hexo</code>目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br></pre></td></tr></table></figure>
<p>修改文件中对应的项，vim操作见<a href="https://blog.csdn.net/wuyuefei3/article/details/81139343">linux下使用vim编辑文件并保存</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;hexo; # 需要修改的部分</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>重启Nginx服务，使得改动生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="创建git钩子">创建Git钩子</h2>
<blockquote>
<p><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">git钩子</a>在此处命名为<code>post-receive</code>也就是该挂钩在git提交之后自动执行文件里的内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;var&#x2F;repo&#x2F;hexo_static.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>
<p>在该文件中添加代码，指定Git的工作树（源代码）和Git目录（配置文件等）的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">git --work-tree&#x3D;&#x2F;var&#x2F;www&#x2F;hexo --git-dir&#x3D;&#x2F;var&#x2F;repo&#x2F;hexo_static.git checkout -f</span><br></pre></td></tr></table></figure>
<p>保存并退出文件，并将该文件变成可执行文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;var&#x2F;repo&#x2F;hexo_static.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>
<h2 id="回到本地配置">回到本地配置</h2>
<p>在站点_config.yml中修改博客url地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">url: http:&#x2F;&#x2F;server-ip # 没有绑定域名时填写服务器的实际 IP 地址。</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>
<h2 id="通过git部署">通过Git部署</h2>
<p>先在任意位置处打开cmd, 从服务器上把<code>hexo_static</code>仓库克隆下来, 以此来将服务器地址添加到受信任的站点中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@server_ip:&#x2F;var&#x2F;repo&#x2F;hexo_static.git</span><br></pre></td></tr></table></figure>
<p>注意在第一次进行这一步时会提示是否继续，选yes即可。<code>git@server_ip</code>这里的<strong>git</strong>不是固定的，而是你的服务器用户名（例如root/admin，<strong>我曾在这个错误上困扰了许久许久</strong>！！！），此外<strong>server_ip</strong>就是你的远程服务器IP地址。</p>
<p>再编辑Hexo的<code>config.yml</code>文件，找到Deployment, 修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo:</span><br><span class="line"> 	#同步部署到服务器和github</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;GithubName&#x2F;GithubName.github.com </span><br><span class="line">    hexo: git@server_ip:&#x2F;var&#x2F;repo&#x2F;hexo_static.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure>
<p>于是就可用<code>hexo d</code>命令来部署了到服务器了。</p>
<h2 id="外部访问服务器网站">外部访问服务器网站</h2>
<p>部署到服务器之后，需要开启80端口(与Nginx配置文件中同步)，详情见<a href="https://www.aliyunfuwuqi.com/ecs/2254/">https://www.aliyunfuwuqi.com/ecs/2254/</a>开启了80端口并成功部署网站之后，就可以通过http://xx.xx.xx.xx来访问你的网站啦！</p>
<p>欢迎大家访问<a href="http://39.106.111.188/">我的网站主页</a>。</p>
<h2 id="参考">参考</h2>
<p><em>用Hexo部署博客到Ubuntu服务器：<a href="https://www.jianshu.com/p/16b89f4f7136">https://www.jianshu.com/p/16b89f4f7136</a></em></p>
<p><em>阿里云服务器远程连接：<a href="https://www.cnblogs.com/chenyablog/p/10281995.html">https://www.cnblogs.com/chenyablog/p/10281995.html</a></em></p>
<p><em>linux下使用vim编辑文件并保存：<a href="https://blog.csdn.net/wuyuefei3/article/details/81139343">https://blog.csdn.net/wuyuefei3/article/details/81139343</a></em></p>
<p><em>linux下chmod +x的意思？<a href="https://blog.csdn.net/u012106306/article/details/80436911">https://blog.csdn.net/u012106306/article/details/80436911</a></em></p>
<p><em>Git钩子的使用<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90</a></em></p>
]]></content>
      <tags>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>西安交大&amp;百度竞赛总结</title>
    <url>/2019/07/01/20Baidu-XJTU_BigData_Contest/</url>
    <content><![CDATA[<p><img src="/images/BaiDuContest.jpg" alt="cover"></p>
<a id="more"></a>
<h1>西安交大&amp;百度竞赛总结</h1>
<p>比赛的相关介绍见：<a href="https://dianshi.baidu.com/competition/30/rule">百度点石竞赛总结</a> ，数据分为遥感图像和用户访问数据两部分，要求参赛者根据这两部分数据预测新地点的标签，分类内容如下图</p>
<p><img src="/assets/1561900835759.png" alt="1561900835759"></p>
<h3 id="第一版思路">第一版思路</h3>
<p>这是第一次参加接触相关领域的知识，作为一个小白，很想从这个竞赛入手来学习深度学习相关的知识技能。起初分别对遥感图像和用户访问数据建立单网进行深度学习，整体使用的是keras框架，考虑到keras易于学习和使用，且能够以较快的尝试更多的创意。</p>
<p><img src="/assets/1561952095923.png" alt="1561952095923"></p>
<h4 id="图像处理">图像处理</h4>
<p>对图像部分的数据尝试了Inception系列、VGG系列、NasNet及Xception等，构建模型时，初始采用各个模型在imgnet网络上的训练权重，在各网的基础结构后添加9个神经元的Dense层，用于最后的分类。经过实验，发现NASNet的Accuracy的结果较好，在0.42左右。</p>
<h4 id="用户访问数据处理">用户访问数据处理</h4>
<p>对用户数据部分试验了Rnn、Xgboost及Lightgbm等网络</p>
<h4 id="数据融合">数据融合</h4>
<p>数据融合实际上一开始用了权重相加，效果不好，只有0.71左右，后来认为为什么不将不同所求的概率作为输入，用验证集作为最后的一个xgboost的训练集来训练融合模型，最后效果为0.7240，比直接通过加权相加的效果好了很多，可以调节xgboost的参数来提高效果。</p>
<h3 id="第二版思路">第二版思路</h3>
<h4 id="数据预处理">数据预处理</h4>
<p>经队员提醒，发现所给的遥感图像中有很多脏数据，如下图所示</p>
<p><img src="/assets/1561964040175.png" alt="1561964040175"></p>
<p>有一部分图块是全黑的，还有一部分图块是被云朵遮盖的，剩下的就是只能看到部分区域图，这也许会影响到模型的质量，我们第二版的思路就是将这些图片剔除掉之后再使用NasNet进行建模。</p>
<p>随后又对图像做了一些预处理，包括去雾、旋转等，后来还使用GNN对图片进行了增强，从100×100的小矩阵增强到了224×224的矩阵形式，随后送入到神经网络中进行训练，最后的得到的实验结果是…。</p>
<h4 id="尝试用户访问数据新模型思路">尝试用户访问数据新模型思路</h4>
<p>虽然用户的访问数据比较适合序列的训练方式，我们团队尝试将访问数据按照不同的特征问题归类，如一些人数、假期等等。归类之后将其作为24维的输入即7×26×24，送到NasNet等卷积神经网络中进行训练，通过将图片数据和用户数据送到同一个网络中进行训练，得到了的0.68的效果。</p>
<h3 id="总结">总结</h3>
<p>通过参加此次竞赛，我基本了解了大数据相关竞赛的参赛思路，如何去构建模型，如何去调整参数，如何从loss及accuracy等的变化中读取模型构建的情况，是否产生了过拟合等等。也了解了当前<a href="http://baijiahao.baidu.com/s?id=1599943447101946075&amp;wfr=spider&amp;for=pc">比较流行的几个深度学习框架</a>同时，我也认识到了讨论区的重要性，有些大佬会把最初的demo分享在github上， 通过学习、讨论及复现能够了解别人的思路，能够发现自己忽略的问题。竞赛是了解相关知识的较好途径，大佬们分享的代码简直就是宝物。</p>
<p>下面附上几版代码以便自己和别人后续的学习使用：</p>
<ol>
<li><a href="https://github.com/czczup/UrbanRegionFunctionClassification">baseline</a></li>
<li><a href="https://github.com/SeaEagleI/2019_Baidu-XJTU_BigData_Contest">69.4成绩</a></li>
</ol>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/qq_34919792/article/details/93976813">第五届百度&amp;西安交通大学大数据竞赛初赛思路总结</a></p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>K-means与MeanShift</title>
    <url>/2019/04/04/18K-means&amp;MeanShift/</url>
    <content><![CDATA[<p><img src="/images/machine.jpg" alt="cover"></p>
<a id="more"></a>
<h1>k-means</h1>
<p>k-means算法是机器学习中的一种常见聚类算法。聚类算法属于无监督学习，相比于回归、朴素贝叶斯等少了标签y的信息。K-means算法是将样本聚成k个簇，具体执行步骤如下</p>
<p>（1）      随机选区k个对象作为初始聚类中心</p>
<p>（2）      计算每一个样本到簇的距离来划分</p>
<p>（3）      再次计算每个聚类中心</p>
<p>（4）      计算标准测度函数，直到达到最大迭代次数，则停止，否则，继续操作</p>
<p>通过不断地调整聚类中心的位置，使得聚类中心逐渐转移到与附近样本距离和最小的位置，这里通过标准测度函数进行计算。这里的距离有很多种计算方式，常见的有欧式距离和曼哈顿距离。</p>
<p>​       该算法通过调用sklearn.cluster的Kmeans类实现模型的训练，再通过简单的绘图来表示聚类中心与样本的关系，如图所示。</p>
<p><img src="/assets/20180228115245278-1554340564954.gif" alt="20180228115245278"></p>
<p>图6-1 K-means算法确定的4个聚类中心</p>
<p><strong>算法优点：</strong></p>
<ul>
<li>
<p>速度快，计算简便</p>
</li>
<li>
<p>聚类效果较优</p>
</li>
<li>
<p>算法的可解释度比较强</p>
</li>
</ul>
<p><strong>算法缺点：</strong></p>
<ul>
<li>
<p>必须提前知道数据有多少类/组</p>
</li>
<li>
<p>对于不是凸的数据集比较难收敛</p>
</li>
<li>
<p>采用迭代方法，得到的结果只是局部最优</p>
</li>
<li>
<p>初始聚类中心的选择</p>
</li>
<li>
<p>对于离群点和噪声点比较敏感，模型受影响较大</p>
</li>
</ul>
<p><strong>算法延伸：</strong></p>
<p>​             对初始聚类中心的选择进行改进，有了K-means++、二分K-means等等<br>
采用MeanShift避开对数据集聚类中心K的选择</p>
<h1>MeanShift均值漂移</h1>
<p>​       MeanShift均值漂移算法也是一种常见的聚类算法，它的工作方式跟K-means很相似，两者都是通过不断地调整位置，进而逼近样本密度最大的区域中心。它常被用在图像识别中的目标跟踪，数据聚类、分类等场景，前者的核函数使用了Epannechnikov核函数，后者使用了Gaussian(高斯核函数)</p>
<p>​       <strong>算法执行步骤：</strong></p>
<ul>
<li>
<p>确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬山算法，在每一次迭代中向密度更高的区域移动，直到收敛。</p>
</li>
<li>
<p>每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的密度。在每一次移动中，窗口会想密度更高的区域移动。</p>
</li>
<li>
<p>移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即一直移动到圆内密度不再增加为止。</p>
</li>
<li>
<p>步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数据点所在的滑动窗口进行聚类</p>
</li>
</ul>
<p>迭代过程如下图</p>
<p><img src="/assets/201802281615434.gif" alt="201802281615434"></p>
<p>图6-2 MeanShift算法迭代过程</p>
<p><strong>算法优点：</strong></p>
<ul>
<li>
<p>不同于K-Means算法，均值漂移聚类算法不需要我们知道有多少类/组</p>
</li>
<li>
<p>基于密度的算法相比于K-Means受均值影响较小</p>
</li>
</ul>
<p><strong>算法缺点：</strong></p>
<ul>
<li>窗口半径r的选择可能是不重要的</li>
</ul>
<h1>随机森林</h1>
<p>​    随机森林就是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。</p>
<p>​    其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。</p>
<p><strong>每棵树的按照如下规则生成：</strong></p>
<p>（1）   如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的抽取N个训练样本（这种采样方式称为bootstrap sample方法），作为该树的训练集；</p>
<p>（2）   如果每个样本的特征维度为M，指定一个常数m&lt;&lt;M，随机地从M个特征中选取m个特征子集，每次树进行分裂时，从这m个特征中选择最优的;</p>
<p>（3）   每棵树都尽最大程度的生长，并且没有剪枝过程</p>
<p><strong>算法优点：</strong></p>
<ul>
<li>
<p>在当前所有算法中，具有极好的准确率</p>
</li>
<li>
<p>能够有效地运行在大数据集上</p>
</li>
<li>
<p>能够处理具有高维特征的输入样本，而且不需要降维</p>
</li>
<li>
<p>对于缺省值问题也能够获得很好得结果</p>
</li>
</ul>
<p><strong>错误率影响：</strong></p>
<ul>
<li>
<p>森林中任意两棵树的相关性：相关性越大，错误率越大</p>
</li>
<li>
<p>森林中每棵树的分类能力：每棵树的分类能力越强，整个森林的错误率越低</p>
</li>
</ul>
<h1>参考文章</h1>
<p><a href="https://blog.csdn.net/Katherine_hsr/article/details/79382249">常见的六大类聚类算法</a></p>
<p><a href="https://www.cnblogs.com/gczr/p/7097704.html">随机森林</a></p>
]]></content>
      <categories>
        <category>计算机理论基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>k-means</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈深度学习</title>
    <url>/2019/04/04/19Deep-Learning/</url>
    <content><![CDATA[<p><img src="/images/nuralNetwork.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="浅谈深度学习">浅谈深度学习</h2>
<p>这几年深度学习真的很火，其热门程度渐渐超过了传统的机器学习算法。很多学校都专门开设了深度学习这样一门学科，通过了解后才渐渐感受到其思想。</p>
<p>我最初对深度学习的印象一步步的发生了变化，这个变化通常是当下学习新东西的整体脉络。每当我一搜深度学习，总是会有很多资料铺天盖地迎面而来，水文好文参差不齐，总之给我的印象就是繁杂。繁杂到我不知道从哪里入手，不知道如何迈出我的第一步。资料确实是太多了，我看到有推荐Coursera上deeplearning.ai的视频，有推荐AlexNet、GooleNet等网络的专业论文，还有推荐的其他各种各样的文档资料及培训课。正是这些东西让我难以下手，其实我只想一窥其全貌，看看适不适合我，决定深入多深。</p>
<p>于是我自己找了本书，在图书馆简单的浏览了一遍，就是下面这本。我不能说它有多好，因为这是我看的第一本深度学习书籍。但我觉得对入门还是比较有帮助的。</p>
<p><img src="/assets/1561272851686.png" alt="1561272851686"></p>
<p>在看完这本书后，我感叹科学家的伟大，深度学习模拟人脑的工作方式，搭建出了一个神经网络。举个例子：当我们在看到一只猫时，我们是如何判断出它是一直猫的。在这个过程中，我们的眼睛把看到的景象通过一层一层的神经元传到大脑，在大脑又拿出其对各类动物体态特征的记忆进行对比，通过不断的比较验证，最终判断出它是一只猫。而神经网络的工作方式也很类似，为了量化我们的输入的各维特征，才出现了权重，同时为了能够更深入的分析各个神经元的内在关系，出现了激活函数等。</p>
<p>我是通过百度电石上的一个大数据比赛来入手深度学习的，身边有几位大佬，很少但很宝贵。我通过学习他们的源代码，渐渐明白了在python语言中，神经网络的搭建过程。我看到他们设计的一百多层的网络都惊呆了，感觉这没有个三五年功夫是很难弄出来的，问他们也都说是经验，让人无从下手，难以琢磨。</p>
<p>但事实上，要想一窥其全貌还是比较容易的，因为有很多经过多层封装的深度学习函数库，如keras、pytorch、caffe等等，他们的使用就会相对容易一些。在这里要介绍一下网络，常用的网络组成有全连接层、池化层、压平层等等，而我们经常见到的AlexNet、GoogleNet、NasNet则大多数都是在比赛中提出来的已经设计层次结构的神经网络，对于我们小白而言，只需要将他们设计好的神经网络拿过来用一用就能学到不少东西了，而我们只需要修改一下输入输出。有一份大佬的代码真是非常宝贵，如果你也想入门，建议你到大数据平台上看看题目，下载几份源码学习。认真的把每个函数搞懂，每个参数的意思搞清楚，再慢慢深入去研究原理公式，我觉得这才是学习的正确思路。我觉得一上来就学习深层的理论知识很容易磨灭人的兴趣和意志，不利于长期学习。</p>
<p>深度学习如今的应用也是很广泛，新的网络结构和技术也是层出不穷，进入这行确实需要勇气，但是在深入学习理论知识之前，一定要先学习工具包怎么用，然后尝试自己写，最后再去推倒公式。大佬们由于都已经经历过这个过程，所以他们听说要学习深度学习一上来就推荐看西瓜书、花书等等，这些书确实囊括了很多精华知识点，却不一定适合当下的我们。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯和软微</title>
    <url>/2019/03/25/16LanQiao&amp;SS/</url>
    <content><![CDATA[<p><img src="/images/contest.jpg" alt="cover"></p>
<a id="more"></a>
<p>时隔一月，尤其是在考完蓝桥杯之后又有一些体会，在此记录，整理思路。</p>
<h2 id="第十届蓝桥杯初赛">第十届蓝桥杯初赛</h2>
<p>为这个蓝桥杯，准备了将近一个月的时间，这一个月数学没看、英语没背、课也没有好好上，将历年的题大部分都敲了一遍，视频也过了一遍。可是在那天的发挥却不尽人意，找不到问题出在哪，考试的时候就是不知道什么原因就自己绕进去了，丢了两道很简单的题的分数，这让我郁闷了好久。</p>
<p>其实，这应该是很正常的事情，就像孙兰昌学长跟我说的那样，付出并不一定有回报，有些事情就不是自己想的那样。但是不付出，肯定是一点机会都没有的，其实这一个月自我感觉编程能力还是有一定程度的提高的。然而由于一部分原因，让我没有完全发挥出自己的水平，这可能是因为紧张的缘故？其实我自己考完试都难以相信，自己怎么会在那么简单的问题上兜圈子（没错，就是那个BYQ）。</p>
<p>我起初的想法是，这次可能是最后一次参加蓝桥杯了，我希望能够突破一下自我，能够进一次决赛，我相信大学到现在的积累应该给我尝试的机会，可是现在看来，多半是没希望了。不过我也不应该在这件事上纠结太久，毕竟还有其他的事情等着我去做。</p>
<h2 id="本学期课程吐槽">本学期课程吐槽</h2>
<p>接下来在聊聊对这学期课程的感受，这学期从开学到现在，让我最期待的无非就是机器学习课程了，可是当我听了一节课、两节课之后，失望的表情溢于言表。老师只是很简单很简单的介绍了一下概念性的知识，这些东西去了解是很快的、毫不费力的，我不理解这样授课有什么价值。外聘的老师都这么水，更不用提专业的老师了，除了马丽老师的课（不爱听），再找个有水准的就很难了。</p>
<p>可能这仅仅是我的体会，不过这种体会预示着我应该做出一些改变，而不是按部就班的跟着浪费时间，我觉得应该用这些时间做些更有价值的事情。但其实这些课程的初衷是非常好的，计算机英语无处不在、操作系统是考研必考课程、机器学习当下非常流行等等，可是我从我们专业的老师那里体会不到半点水平。所以我还不能直接略过这些课、考虑到又不能听，所以解决办法只有一个，那就是上课自学或者上课补作业，然后课下按照自己的复习计划进行，这是我目前想到让自己感觉好一些的解决措施。</p>
<h2 id="软微复试交流">软微复试交流</h2>
<p>在3月19日下午，我跟董慧芹一同去了趟北大的软微学院，那天是复试的第一天，我们打算去碰碰运气，看能不能认识一两个大佬。软微距离北石化也就三公里，坐公交十多分钟就到。到了那，先冷静的观察了一波，问了问，才知道技术组在一层面试。于是在一层门口观望，正好遇到了一个提前来打探情况的复试大佬，他是化学专业跨考，还是二战考生。</p>
<p>他跟我分享了很多自己准备软微的体会，还跟我聊了面试老师的问题以及需要注意的事项，他跟我说了好几个专业方向的面试问题，我竟然一个都答不上来。虽然有一部分知识是还没学，但另一部分知识确实是没接触过！学校的课程里从来就没有提过，自己也没用过，因为没有那样的需求，平时接触到的都是很简单的操作，基本都没有优化问题。后来那个师兄还跟我讲了很多自己复习的经验，以及复试群里讨论的内容，我真的十分庆幸，我认识了这样一个师兄，我特别希望他能顺利上岸，也能给我树立个榜样，让我更有动力去准备。</p>
<p>这让我意识到，我之前学的东西都太shallow了，其实自己能接收的知识还能再多一些，可是课堂上却给不了了，在课下又想着做各种各样的事情，于是就被死死的限制而出不来，并且无论是学分绩还是在同学中的威望，让我很难去摆脱这样的瓶颈。这是我近期一度困惑的问题，我不知道该怎么去调整了。</p>
<h2 id="继续考研复习规划">继续考研复习规划</h2>
<p>现在都已经三月底了，已经耽误了不少复习时间了，下面我要开始认真的复习考研内容了。对于放下的数学，我目前的想法是将寒假讲的知识先过一遍，做做例题。过完一遍之后，再从微分方程那块继续往后复习，得赶紧把高数先整体过一遍，然后再选择重复或者是看线代。</p>
<p>对于英语，要开始背单词，回到高中那会手写纸上两排，捂着复习、重复的记忆。我在这种方式下记单词的效率还是挺高的，为期21天，如果不能坚持，那就刷题。专业课上课时间补，就这些了，希望自己继续坚持，继续加油！！！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>京东手机评论爬虫</title>
    <url>/2019/02/26/15JDComment-Spider/</url>
    <content><![CDATA[<p><img src="/images/jdSpider.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="所用工具">所用工具</h2>
<ul>
<li>Chrome 版本 72.0.3626.109（正式版本） （64 位）</li>
<li>Python 3.5.2 :: Anaconda 4.2.0 (64-bit)</li>
</ul>
<h2 id="数据采集">数据采集</h2>
<h3 id="确定待采集数据">确定待采集数据</h3>
<p>对评论所含内容进行简单的分析，初步确定所需要抓取的内容。首先，在京东商城手机信息界面的用户评价中含有昵称、会员等级、评价星级，评价内容、手机型号、购买时间等等。</p>
<p>其中通过分析会员等级与购买的关系，可以给为不同会员提供不同的产品做参考。分析评价内容可以大概可以推断出消费者对该产品的态度、以及哪些回复关注度比较高等等。分析购买时间可以了解到消费者集中的购买时间段。<strong>这些分析对商品广告的精准投放以及为消费者提供更个性化的服务提供了重要参考</strong>。</p>
<h3 id="确定采集对象">确定采集对象</h3>
<p>选择按评论数降序排列的手机型号，选择Apple iPhone 8 Plus(A1864) 64GB的评论数据进行采集</p>
<h3 id="采集准备">采集准备</h3>
<p>（robots协议说明：robots是网站对爬虫的限定规则，它规定了那些爬虫可以爬，那些数据可以爬）</p>
<p>因此在采集之前，查看京东商城的robots协议，如下图</p>
<p><img src="/assets/1551319945219.png" alt="1551319945219"></p>
<p>参考robots协议规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: 指定对哪些爬虫生效</span><br><span class="line">Disallow: 指定不允许访问的网址</span><br><span class="line">Allow: 指定允许访问的网址</span><br></pre></td></tr></table></figure>
<p>通过分析robots协议的内容，而下面即将采集的目录在根目录的comment的子目录下，不涉及到用户的个人隐私，因此可以继续进行采集。</p>
<p>但是在采集过程中，添加sleep函数，既为了防止频繁访问ip被封，也防止高频度访问对网站带来的负荷。</p>
<h3 id="开始采集数据">开始采集数据</h3>
<h4 id="分析网页">分析网页</h4>
<p>首先选择一款评论数目多的手机，按照评论数降序排列</p>
<p><img src="/assets/1551163850458.png" alt="1551163850458"></p>
<p>点击进入手机信息页面，在默认手机参数选择下</p>
<p>按F12打开调试界面，打开network面板并在过滤器中填入“comment”，如下图<img src="/assets/1551164094744.png" alt="1551164094744"></p>
<p>此时，点击商品评价，筛选到如下结果</p>
<p><img src="/assets/1551164279099.png" alt="1551164279099"></p>
<p>含有pageComment字段的即为服务器返回的页面评论数据，右键该文件-&gt;copy-&gt;Copy link address复制url并在url地址栏进行访问。访问结果如下图</p>
<p><img src="/assets/1551164441005.png" alt="1551164441005"></p>
<p>可以很容易的看到，服务器返回给页面的数据是JSON格式的数据。</p>
<p>可以先使用<a href="http://www.bejson.com/jsoneditoronline/">JSON在线编辑器</a>进行json解析，在解析时发生错误，这是由于页面的数据的头部和尾部有一些其他的字符使得页面内容不完全是json数据，去掉第一个’(‘以及其之前的字符，同时去掉最后一个’)'以及其之后的字符即可。整理之后的结果如下图<img src="/assets/1551164892027.png" alt="1551164892027"></p>
<p>从图中可以清楚的看到，评论共有100页，每页的comment有10条。单独点开其中一条评论数据如下图</p>
<p><img src="/assets/1551164975991.png" alt="1551164975991"></p>
<p>可以清楚的看到我们所需要的数据。</p>
<p>那么新的问题来了，京东界面所写评论有163万+条，那其他的数据都去哪了？查看一下第100页后面，看有没有发现</p>
<p><img src="/assets/1551165225666.png" alt="1551165225666"></p>
<p>看了之后才发现，还有114万+用户给了默认评价，为了分析更准确，加上这部分数据(其实点开也就100页，其他的可能服务器就没留着)。按照同样得方式，获取这部分评论的通用url<img src="/assets/1551165875856.png" alt="1551165875856"></p>
<p>尽管如此，也才仅有1500条左右的数据，不过在评论的菜单中还有追评、好评、中评、差评等，把这些也算进来，对比比较差异</p>
<p><img src="/assets/1551167389012.png" alt="1551167389012"></p>
<p>发现不同评价的score不同，综合大约有4000~5000条数据</p>
<p>继续统计手机不同参数所含的评论。在这里我将手机颜色从“金色”改为了“深空灰色”，按照同样的方式查看url。并与之前获取的进行对比。如下图</p>
<p><img src="/assets/1551166489422.png" alt="1551166489422"></p>
<p>对比之后发现，不同颜色的产品ID(productid)发生了变化。但其实评论区域还是各种颜色都有，所以这也是手机评论数据，只不过为了美观，在每次更改手机参数选择时进行了刷新(动态生成)。</p>
<p>根据这些url参数，就可以尽可能多的爬取该款手机的评论数据，具体代码请移步<a href="https://github.com/YuleZhang/JDComment_Spider"><strong>JDComment_Spider</strong></a>，里面的SpiderScript是一个完整的京东评论爬虫脚本，并且采用了随机浏览器和延时访问来防止爬虫被封，为了获取完整的数据，加入了try…except防止程序中断崩溃。</p>
<h4 id="思考">思考</h4>
<p>​	经过上面的分析，可以看到数据量非常有限，远远没有达到163万条。经分析，有以下两种可能：</p>
<ol>
<li>出现了数据造假，这个数字可能是刷出来的（机器或者水军）</li>
<li>真的有这么多的评论，但这时候系统可能只显示其中比较新的评论，而对比较旧的评论进行了存档。</li>
</ol>
<h3 id="拓展采集">拓展采集</h3>
<p>通过采集之后发现京东的评论数据没有达到要求，于是到淘宝上看同款产品的评价进行搜集。</p>
<p><img src="/assets/1551336637383.png" alt="1551336637383"></p>
<p>能找到包含json格式的评论数据，但是使用python进行访问时，却没有跳转到应该有的数据界面，而且跳到了其他界面，如下图</p>
<p><img src="/assets/1551336746478.png" alt="1551336746478"></p>
<p>这意味着，没有登陆授权，无法查看评论信息(上面能看到评论信息，也是因为事先登陆过了)。因此只能采取selenium模拟浏览器行为来先登录，然后再获取这部分评论信息。</p>
<p>python+selenium+webdriver的探索及问题：</p>
<p>通过一系列的碰壁探索，发现selenium无法绕过淘宝登陆界面的验证，淘宝网应该是有识别自动化脚本登陆的反爬机制，根本无法获取登陆状态，无法登陆。</p>
<p>通过伪造请求头来获取淘宝数据：</p>
<p>登陆淘宝后，在淘宝主界面刷新，来获取登陆的cookies信息，如下图</p>
<p><img src="/assets/1552033319705.png" alt="1552033319705"></p>
<p>随后用这部分cookies来构造请求头，如下图所示</p>
<p><img src="/assets/1552033572299.png" alt="1552033572299"></p>
<p>这样，就能访问淘宝上需要登陆才能获取的页面信息，不过当你尝试就会发现，即使这样，在短时间连续访问多次，也很容易被检测到，从而限制页面的获取数量。我使用该爬虫在不同的时间段爬了六七次，每次requests到第17次就会出错了，有待完善。详细代码见<a href="https://github.com/YuleZhang/JDComment_Spider/blob/master/Taobao_Spider.ipynb">淘宝数据爬取</a> （预览不了的可以下载看）。</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/whatisfantasy/p/6440585.html">搞定python多线程和多进程</a></p>
<p><a href="http://www.bejson.com/oldbejson/jsoneditoronline/">JSON在线编辑器</a></p>
<p><a href="https://www.cnblogs.com/qun542110741/p/9221040.html">Python爬虫，抓取淘宝商品评论内容</a></p>
<p><a href="https://github.com/lining0806/PythonSpiderNotes">Python入门网络爬虫之精华版</a></p>
<p><a href="https://www.cnblogs.com/taceywong/p/6602736.html">Selenium Python文档：四、元素定位</a></p>
<p><a href="https://www.cnblogs.com/junrong624/p/5533655.html">为何大量网站不能抓取?爬虫突破封禁的6种常见方法</a></p>
<p><a href="https://blog.csdn.net/LaoChengZier/article/details/80705298">处理Jupyter Notebook报错：IOPub data rate exceeded</a></p>
]]></content>
      <categories>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>《福尔摩斯思考术》读书笔记(2)</title>
    <url>/2019/01/20/14HolmesThinking/</url>
    <content><![CDATA[<p><img src="/images/HolmesThinking.jpg" alt="cover"></p>
<a id="more"></a>
<h4 id="福尔摩斯思考术-2-如何形成深具洞察力及自我认知的思维模式">福尔摩斯思考术（2）——如何形成深具洞察力及自我认知的思维模式</h4>
<p>每件事情不是只有继续和放弃两个选项，还可以选择“暂时放弃”</p>
<p>人生的岔路千千万万，走错一步太正常了，没必要在更窄的方案里做选择，当发现走的很难的时候，不如试试后退一步重新来过，或许就有新的解法。</p>
<p>做各种各样别的事情，能让我们有更大概率获取到相关的弱连接提示。(后台运行)</p>
<p>你永远不知道什么样的若连接可以触动正确解题的开关，你只能做到<strong>让尽可能多的弱连接进来</strong>。</p>
<p>把脑子里的单纯的抽象推理转化为视觉，就能让脑子有更多空余进程去思考别的事情。例如写题要把式子列出来一步步计算、福尔摩斯往往会在现场根据蛛丝马迹进行推理都是这个意思。</p>
<p>尤其是结论“好”的时候，我们尤其会让大脑放松在过程审视上的警惕性。会导致的后果是，无法分辨好的结恶果究竟是不是运气导致的，因此结果越好，反而越难以学到东西。</p>
<p>关于过程和结果举例：</p>
<ol>
<li>所有植物都需要水</li>
<li>玫瑰需要水</li>
<li>所以玫瑰是植物</li>
</ol>
<p>如果没有看出这个推理哪有问题，就说大脑关注结论太久，所以“玫瑰是植物”这个正确结论对他们有太大的影响。</p>
<p>换几个字之后</p>
<ol>
<li>所有动物都需要水</li>
<li>玫瑰需要水</li>
<li>所以玫瑰是动物</li>
</ol>
<p>一对比就知道问题，在第二个例子中，发现结果不对，才会去思考整个推理过程，而第一个例子，则往往让人们忽视其逻辑中的漏洞。</p>
<p>所以你会发现算命的除非能确定引发你的焦虑，让你掏钱消灾，否则通常之说好话，不是我们认不清，是我们不愿意认(不愿去思考过程)，因为如果他说了不好的呢？你就突然变“聪明”了， 开始会去抓他的逻辑漏洞了。</p>
<p><strong>大脑在推理时一直有一种倾向，就是试图抓住与之相关的所有信息，并尽可能将其合理化从而应用到自己的推理过程之中。</strong></p>
<p>思维训练导致的个人思维能力的提升本身就已经是一种回报，只是很难被感知力差的人量化而已。</p>
<p>衡量学习和实践性价比的“性”的一端最好的标不是能得到多少显而易见的收益，而是自身能力有多大程度的提高，这才是最大的隐形收益。</p>
<p>有些人总能在学习新鲜事物的时候得到多巴胺的反馈，因为进步的够快，因此这些人对新的东西就保持可一种习惯性渴望——潜意识告诉它们，又可以获得奖赏中枢分泌的奖赏物质了；而另一些人学东西相对较慢，他们的进度就会落后于别人。如此，它们就没有这种渴望。</p>
<p>值得一提的是：</p>
<ol>
<li>想坚持做一件事，就要尽快<strong>试图从中获取到多巴胺的奖励</strong>，慢了就没动力</li>
<li>坚持做1，能让自己<strong>对新事物保持旺盛的好奇心，从而获得更多的红利</strong>。</li>
</ol>
<p>我们曾经说过“分享是最好的学习”，大抵也是如此，尤其是当你要把一件事跟一些基础较弱的人讲明白时，你就不得不将那些原本显而易见的、自以为理所当然不需要思考的道理拉出来重新审视，在这个过程中，往往你会发现，其实那些最基础的概念你并没有全弄明白。</p>
<p><strong>挑战，是最大限度地激活我们思维的方式</strong></p>
<p>信息了解的多，一般情况下是只好不坏，最多就是无用，但由于他会影响到一个人的正常决策信息，因此如果是无用的话，反而就是累赘了，这会让一个一无所知的人对形式产生错判，从而进行非理性的下注。</p>
<p>有时候，我们的大脑会可以忘记自己在大多数情况下都很愚蠢的事实，只救助几次正确的不放，除此以外，大脑也很擅长将自己的推理往合理化的方向靠。此时，做笔记或记录的习惯会将自己的思维过程记录下来，来认清自己。</p>
<h4 id="自己的体会：">自己的体会：</h4>
<p>在跟同学将程序的时候就发现，很多函数的参数自己也并不明白，完全是所见即所得，从网上找到的东西执行的通，就很少再去思考它的参数以及用法等等，这会让我忽视很多细节语法。然而在跟同学讲时，就发现了盲区。</p>
<p>然而对于这件事情，我却有自己的想法，尽管我不知道它是否客观。我觉得再程序这方面上，每个函数都有很多的参数，有各种各样的用法， 如果例子的用法就能满足我的当下需求，我就不需要再分散注意力去纠结那个东西，因为是否搞清它的所有用法对我当前追求的东西并没有联系。并且，这些东西在网上都可以轻易的获取到。我追求**“所需即所得”** ，即我在做项目或者东西时接触到需求，会让我选择性的了解项目的部分或者整体，界面或者原理等等。</p>
<p>并且在生活中，我也不是一个事无巨细的人，这就让我更难关注那些细节，那些基础的，不需要思考的东西，尽管我知道这是大脑在偷懒，不过我觉得它是该适当休息。不过在应对<strong>考试</strong>、<strong>比赛</strong>以及<strong>重大决策</strong>等事件上，我觉得应该还是遵循“<strong>分享是最好的学习</strong>”的原则，因为这些事件都需要细节、基础作为支撑。</p>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机考研备考规划</title>
    <url>/2019/01/13/12CS-Preparation/</url>
    <content><![CDATA[<p><img src="/images/cs-preparation.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="院校选择">院校选择</h2>
<h3 id="个人期望">个人期望</h3>
<p>自己喜欢的方向或者专业方面，哪个学校的实力比较强，相关方向的老师比较多</p>
<h3 id="地域">地域</h3>
<p>不同的地域在就业时会有不同的优势</p>
<p>在大城市接触到的人脉资源会很有用，但相应考试难度会相对较大</p>
<h3 id="考试难度">考试难度</h3>
<p>统考</p>
<p>专业课</p>
<h3 id="准备知识">准备知识</h3>
<ol>
<li>招生简章</li>
<li>保研名单</li>
<li>夏令营名单</li>
<li>录取名单</li>
</ol>
<p>通过集中的分析，对比不同学校的考试难度和自身的水平，认真理性的选择学校</p>
<h3 id="院校排名">院校排名</h3>
<p>这个不是很重要</p>
<h3 id="一些问题">一些问题</h3>
<p>学校歧视</p>
<p>这个问题不用担心，只要你初试成绩够，可以有不同的情况，可以在校绩点高一些，可以有很多小项目，即使跨考也不用担心。</p>
<p>选好大方向：人工智能还是网络，具体做什么跟导师有关	。</p>
<p>关于调剂</p>
<p>985院校不接受外校调剂，因此优先考虑该学校的其他相关专业。</p>
<h2 id="复习计划">复习计划</h2>
<p><img src="/assets/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-1547368635395.png" alt="复习计划"></p>
<p><img src="/assets/%E5%A4%8D%E4%B9%A0%E5%BB%BA%E8%AE%AE-1547368635395.png" alt="复习建议"></p>
<p>英语：注重阅读</p>
<p>政治：不同的科目对症下药，一定给时间给非主观题。</p>
<p>专业课：把基础打好，王道的复习书，如果是自主命题，早点开始复习把基础打好。必须做的几类题：</p>
<ol>
<li>
<p>历年真题。</p>
</li>
<li>
<p>买一些本科或研究生期末测试题。</p>
</li>
</ol>
<p><img src="/assets/1547368876265.png" alt="1547368876265"></p>
<p>一定不要影响大的安排计划，养成一个固定的习惯。</p>
<p><img src="/assets/1547369569475.png" alt="1547369569475"></p>
<p>第一轮以教材为主、第二轮慢慢以王道书为主，结合教程，多练习</p>
<p>每月有个大的计划，最后再进行细化到每天。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/2018/11/18/11Computer-Neterwork/</url>
    <content><![CDATA[<p><img src="/images/network-note.jpg" alt="network-note"></p>
<a id="more"></a>
<h2 id="第一章-计算机网络概述">第一章 计算机网络概述</h2>
<p><strong>局域网</strong> 覆盖范围小 自己花钱购买设备 宽带固定 自己维护<br>
<strong>Internet</strong> ISP  有自己的机房  对网民提供访问Internet连接<br>
<strong>广域网</strong> 距离较远 花钱买带宽、租服务 不用自己维护</p>
<p><img src="/assets/1542502423577.png" alt="1542502423577"></p>
<h3 id="1-1数据包和数据帧">1.1数据包和数据帧</h3>
<p><img src="/assets/1542503369329.png" alt="1542503369329"><br>
​                                                          url解析过程实例</p>
<p>数据修改mac地址，一步一步转到目标ip<br>
每台路由器的路由表中都记录有连接到同一台交换机的不同主机的ip、mac地址等等，在数据帧从源主机发送过程中，其包含的mac当前地址和下一跳地址会不断修改，在到达不同的路由时，路由器能够根据目标ip所在网段来给数据包指定mac地址，最终实现与目标主机的交互。</p>
<h3 id="1-2osi参考模型">1.2OSI参考模型</h3>
<p><strong>应用层</strong>  所有能产生网络流量的程序<br>
<strong>表示层</strong>  在传输之前是否进行加密 或 压缩处理  二进制 ASCII<br>
表示层错误举例:</p>
<p><img src="/assets/1542504269207.png" alt="1542504269207"></p>
<p>在更改语言之后，会看到网页出现乱码，这就是出现了表示层问题。服务器发送过来的编码格式与我当前网页的解码格式不一致，就会导致网页乱码问题。</p>
<p><strong>会话层</strong> 查看木马</p>
<p>cmd中使用<code>netstat -n</code>命令查看当前会话<br>
<code>netstat -nb</code>能够看到建立会话的程序，一下就能找出来木马。</p>
<p><strong>传输层</strong> 可靠传输 流量控制 不可靠传输</p>
<p>主机访问DNS服务器，只需要一个包就够了，不需要建立会话，这种类型称为不可靠传输。<br>
qq聊天时也是使用的不可靠传输</p>
<p><strong>网络层</strong> 负责选择最佳路径 规划ip地址</p>
<p><strong>数据链路层</strong> 定义了帧的开始和结束     透明传输      差错校验(不纠正)</p>
<p><strong>物理层</strong> 接口标准   电器标准    如何在物理链路层传输更快的速度</p>
<p>每一层较为独立，每一层的变化不会影响其他层，从物理层到应用层，每一层都为上一层提供服务。</p>
<h3 id="1-3osi参考模型和网络排错">1.3OSI参考模型和网络排错</h3>
<ol>
<li>物理层故障   查看连接状态   发送和接收的数据包</li>
<li>数据链路层故障   MAC地址冲突   ADSL欠费    网速协商一致   计算机连接到错误的VLAN</li>
<li>网络层故障   配置了错误的ip地址   子网掩码   配置错误网关    路由器没有配置到达目标网络的路由</li>
<li>应用层故障    应用程序配置错误</li>
</ol>
<h3 id="1-4osi参考模型和网络安全">1.4OSI参考模型和网络安全</h3>
<ol>
<li>物理层安全    外面的网线接到内部交换机</li>
<li>数据链路层安全   ADSL账号密码    VLAN   交换机端口绑定MAC地址</li>
<li>网络层安全    在路由器上使用ACL控制数据流量包</li>
<li>应用层安全    开发的应用程序没有漏洞</li>
</ol>
<h3 id="1-5tcp-ip协议和osi参考模型">1.5TCP/IP协议和OSI参考模型</h3>
<p><img src="/assets/1542510257412.png" alt="1542510257412"></p>
<p><img src="/assets/1542510441573.png" alt="1542510441573"></p>
<p>FCS为校验核</p>
<p><img src="/assets/1542510552860.png" alt="1542510552860"></p>
<h2 id="第二章物理层">第二章物理层</h2>
<h3 id="2-1物理层基本概念">2.1物理层基本概念</h3>
<ol>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ol>
<h3 id="2-2数据通信的基础知识">2.2数据通信的基础知识</h3>
<p><img src="/assets/1543143563956.png" alt="1543143563956"></p>
<p>信道一般表示向一个方向传送信息的媒体。所以平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道</p>
<h4 id="信道">信道</h4>
<p><strong>单向通信</strong> 只能由一个方向的通信而没有反方向的交互</p>
<p><strong>双向交替通信</strong> （半双工通信）通信的双方都可以发送信息，但不能双方同时发送</p>
<p><strong>双向同时通信</strong> （全双工通信）通信的双方可以同时发送和接收信息。例：打电话</p>
<h4 id="基带信号和带通信号">基带信号和带通信号</h4>
<p><strong>基带信号</strong> 像计算机输出的代表各种文字或图像的数据信号都属于基带信号。它直接表达了要传输的信息的信号，比如说话的声音也是基带信号。</p>
<p><strong>带通信号</strong> 把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便再信道中传输。</p>
<p>因此，距离近用基带信号，如从计算机到监视器、打印机等外设的信号都是基带传输。</p>
<h4 id="调制方法">调制方法</h4>
<p>调幅    调频    调相</p>
<h4 id="常用编码">常用编码</h4>
<p>单极性不归零   双极性不归零   单极性归零码   双极性归零码   曼彻斯特编码</p>
<p><img src="/assets/1543146978208.png" alt="1543146978208"></p>
<h4 id="信道的极限容量">信道的极限容量</h4>
<p>香奈法则：没有信号干扰的情况下，码元的传输速率有上限</p>
<p><img src="/assets/1543147043150.png" alt="1543147043150"></p>
<p>香农公式：有信号干扰   无差错传输速率，S/N为信噪比</p>
<p><img src="/assets/1543147112449.png" alt="1543147112449"></p>
<h3 id="2-3物理层下面的传输媒体">2.3物理层下面的传输媒体</h3>
<p>光纤的分类及工作原理。</p>
<p><img src="/assets/1543148711827.png" alt="1543148711827"> <img src="/assets/1543149062538.png" alt="1543149062538"></p>
<h3 id="2-4信道复用技术">2.4信道复用技术</h3>
<p><strong>1.频分复用FDM（Frequency Division Multiplexing）</strong></p>
<p><img src="/assets/1543149527457.png" alt="1543149527457"></p>
<p><img src="/assets/1543149501357.png" alt="1543149501357"> 电话通信中的频分复用技术，通过一级一级的汇总，最终能产生更多的语音信号。</p>
<p><img src="/assets/1543149577579.png" alt="1543149577579"> <strong>2.时分复用 （Time Division Multiplexing）</strong></p>
<p>线路上的数据按照一定的顺序来发送数据</p>
<p><img src="/assets/1543149772049.png" alt="1543149685293"> 可能会造成资源浪费，如下图</p>
<p><img src="/assets/1543149905181.png" alt="1543149905181"> <strong>3.统计时分复用</strong></p>
<p>发的时候没有规律，凑够一个帧就发，但在内容上加上标记</p>
<p><img src="/assets/1543149926590.png" alt="1543149926590"> <strong>4.波分复用WDM（Wavelength Division Multiplexing）</strong></p>
<p><img src="/assets/1543150024141.png" alt="1543150024141"></p>
<h3 id="2-5数字传输系统">2.5数字传输系统</h3>
<p>脉码调制PCM也就是我们所说的广域网，已经提前铺设好了，这样在两个相距较远的局域网直接通信时，可以通过两个局域网的路由器接到广域网中，实现远距离通信。</p>
<p>PCM有两个互不兼容的国际标准，即北美的24路PCM（简称T1）和欧洲的30路PCM（简称E1）采用时分复用，我国采用E1标准。</p>
<p><img src="/assets/1543150295488.png" alt="1543150295488"></p>
<h3 id="2-6宽带接入技术">2.6宽带接入技术</h3>
<p>ADSL（用数字技术对现有的模拟电话用户线进行改造）</p>
<p>使用DMT技术，将频率主要分为三个部分，一部分用传统电话，一部分用于上行信道（向服务器请求数据），一部分用于下行信道（从服务器下载数据），下行信道最多，其特性是流量非对称。</p>
<p><img src="/assets/1543151033236.png" alt="1543151033236"></p>
<p><img src="/assets/1543151225030.png" alt="1543151225030"></p>
<h2 id="第三章-数据链路层">第三章 数据链路层</h2>
<h3 id="3-1数据链路层基本概念">3.1数据链路层基本概念</h3>
<p>下图是数据链路层的简单模型</p>
<p>应用层准备数据—&gt;运输层将其分段—&gt;网络层加ip地址—&gt;链路层加数据帧头帧尾<br>
到了物理层之后，如何频分多路复用、时分多路复用等等、充分利用线路带宽，这是上面物理层已经解决的问题。</p>
<p><img src="/assets/1543715662916.png" alt="1543715662916"></p>
<p>数据链路层不关心物理层速度，不关心是模拟信号还是数字信号，不关心是光纤、铜线，带宽是1M还是10M。</p>
<p>数据链路层在上图中的作用概述起来是这样的：</p>
<p>物理层将数据传到数据链路层之后，数据链路层判断是否数据出错，如果数据正确，拆掉帧头帧尾，传到路由器的网络层，网络层根据ip地址选择路径，决定从路由器的哪个出口出去。随后再传到数据链路层，数据链路层修改MAC地址等信息，加上帧头帧尾，最后发给物理层进行传输。</p>
<p><strong>数据链路层的信道类型</strong></p>
<p>点对点信道：使用一对一的点对点通信方式</p>
<p>广播信道：使用一对多的广播通信方式，过程较复杂。广播信道上的主机数目多，必须使用专用的共享信道协议来协调这些主机的数据发送。</p>
<p><strong>链路与数据链路</strong></p>
<p>链路：点到点的物理线路段，中间没有其他任何的交换结点</p>
<p>数据链路：除了物理线路，还有通信协议控制数据的传输。</p>
<p><strong>帧</strong></p>
<p>把网络层信息加上帧头帧尾，加上物理层地址，加上校验值</p>
<p><img src="/assets/1543716980510.png" alt="1543716980510"></p>
<h3 id="3-2数据链路层解决的三个基本问题">3.2数据链路层解决的三个基本问题</h3>
<h4 id="1-封装成帧">1. 封装成帧</h4>
<p><img src="/assets/1543717172357.png" alt="1543717172357"></p>
<h4 id="2-透明传输">2. 透明传输</h4>
<p>在数据段中出现了与帧头帧尾同样的二进制串，会造成误判。</p>
<p><img src="/assets/1543717298498.png" alt="1543717298498"></p>
<p>ESC相当于转义字符，在收到数据之后去掉这些标识，跟没加一样。</p>
<h4 id="3-差错控制">3. 差错控制</h4>
<p>针对传输过程中可能发生的比特差错，不纠错，有错误就丢，没错误就发。</p>
<p>加上额外的帧检验序列CRC（循环冗余检验）。</p>
<p>CRC的计算过程如下图，除数是随机选取的一个值，在被除数后要补上比除数位数少一位数目的0，在下面例子中就是4位除数，补3个0.。之后在计算时，进行的不是减法，而是做异或运算，最终求出循环冗余码001</p>
<p><img src="/assets/1543718500043.png" alt="1543718500043"></p>
<p>在数据链路层收到这样的数据时，再进行除法的异或运算，但此时被除数后补上的不再是000，而是之前求出来并发送过来的CRC（001），判断最终余数是否为0即可确定数据是否发生了错误。</p>
<p><strong>帧检验序列FCS</strong></p>
<p>CRC是一种常用的检错方法，而FCS时添加在数据后面的冗余码</p>
<p>FCS可以用CRC方法的出，也可以用其他检验方法得出</p>
<p><img src="/assets/1543718652258.png" alt="1543718652258"></p>
<h3 id="3-3两种情况下的数据链路层">3.3两种情况下的数据链路层</h3>
<h4 id="使用点对点信道的数据链路层-ppp">使用点对点信道的数据链路层 PPP</h4>
<p>广域网使用PPP协议，通常用在用户拨号接入因特网，全世界使用最多的协议</p>
<p><img src="/assets/1543719271035.png" alt="1543719271035"></p>
<p><img src="/assets/1543719458006.png" alt="1543719458006"></p>
<p>PPP协议的透明传输：转义法、零比特填充法（只要发现5个连续1，就立即填入一个0）</p>
<h4 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h4>
<p>局域网  使用广播信道的数据链路层  什么协议？</p>
<p>下图中是总线型连接的拓扑结构，数据包发送到各个主机，主机判断目的MAC地址不是本机MAC地址后自动丢弃，是本机MAC地址则接受，当然也可以通过抓包工具捕获到这些数据包，因此说这种网络是不安全的。</p>
<p><img src="/assets/1543720760948.png" alt="1543720760948"></p>
<p>当然，这样的方式也使得广播特性的总线实现了一对一的通信。</p>
<p>使用CSMA/CS（载波监听多点接入/碰撞检测）协议</p>
<p>多点接入：表示许多计算机以多点接入的方式连接在一根总线上</p>
<p>载波监听：就是用电子技术检测总线上有没有其他计算机发送的数据信号以免发生碰撞。</p>
]]></content>
      <categories>
        <category>计算机理论基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议数据包分析</title>
    <url>/2018/11/17/10Network-Package-Capture/</url>
    <content><![CDATA[<p><img src="/images/network.jpg" alt="cover"></p>
<a id="more"></a>
<h3 id="wireshark抓包实验"><strong>Wireshark抓包实验</strong></h3>
<p><strong>1.1</strong>  <strong>学习Wireshark工具的基本操作</strong></p>
<p>学习捕获选项的设置和使用，如考虑源主机和目的主机，正确设置 Capture Filter；捕获后设置 Display Filter。</p>
<p><strong>1.2</strong>  <strong>PING</strong>命令的网络包捕获分析</p>
<p>PING命令是基于ICMP协议而工作的，发送4个包，正常返回四个包。以主机210.31.40.41为例，主要实验步骤为：</p>
<p>（1）设置“捕获过滤”：在 Capture Filter 中填写 host 210.31.40.41；</p>
<p>（2）开始抓包；</p>
<p>（3）在 DOS 下执行 PING 命令；</p>
<p>（4）停止抓包。</p>
<p>（5）设置“显示过滤”: IP.Addr=210.31.40.41</p>
<p><img src="/assets/clip_image002.jpg" alt="img"></p>
<p>（6）选择某数据包，重点分析其协议部分，特别是协议首部内容，点开所有带+号的内容。</p>
<p>（7）针对重要内容截屏，并解析协议字段中的内容，一并写入 WORD 文档中。</p>
<p><img src="/assets/1542435725203.png" alt="1542435715945"></p>
<p>​       通过简单的分析我们可以看到，Ping命令使用ICMP协议，每发送一个包到210.31.40.41后都会收到一个包，一共发送了四个包，收到四个包如所示。分析其中的一个包，可以看到其类型长度为8，数据长度为32byte，见图</p>
<p><strong>1.3</strong>  <strong>TRACERT</strong> <strong>命令数据捕获</strong></p>
<p>观察路由跳步过程。分别自行选择校内外 2 个目标主机。比如，</p>
<p>（1）校内：tracert    210.31.32.8</p>
<p>首先，在执行tracert命令之前，先在Wireshark中过滤选择出210.31.32.8的相关请求。之后，win+r打开cmd界面执行tracert命令</p>
<p><img src="/assets/clip_image005.png" alt="img"></p>
<p>​       截获到的数据如下图，</p>
<p><img src="/assets/clip_image007.jpg" alt="img"></p>
<p>通过对该抓包结果的简单分析，可以看出，抓到的协议类型主要有两种即ICMP和DNS协议，选择不同类型的协议来查看其具体内容。</p>
<p>DNS协议：</p>
<p><img src="/assets/clip_image009.jpg" alt="img"></p>
<p>通过上图简单的分析查看可以得知，DNS协议从10.10.215.246到210.31.32.8，同时包含了UDP协议，源端口为61149，目标端口为53。DNS对域名210.31.40.41进行了84次标准查询，可以看到在DNS的事务ID为：0xc39f，在DNS服务器中的查询结果在第185行。</p>
<p>ICMP协议：</p>
<p><img src="/assets/clip_image011.jpg" alt="img"></p>
<p>ICMP的内容在之前已经分析过了，在这里不在赘述，从图中对比可以看到，data的数据长度变为了64bytes。</p>
<p>（2）校外：tracert    <a href="http://www.sogou.com">www.sogou.com</a></p>
<p><img src="/assets/clip_image013.jpg" alt="img"></p>
<p><img src="/assets/clip_image015.jpg" alt="img"></p>
<p>​       通过简单的分析可以看出，在对搜狗进行抓包时出现了两种协议即ICMP和NBNS协议，其中NBNS协议是 TCP/IP 上的 NetBIOS (NetBT) 协议族的一部分，它在基于 NetBIOS 名称访问的网络上提供<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%90%8D/2836107">主机名</a>和<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/7205014">地址映射</a>方法。</p>
<p><img src="/assets/clip_image017.jpg" alt="img"></p>
<p><strong>1.4</strong>  <strong>端口扫描数据捕获与分析</strong></p>
<p>（1）各组自行下载和安装某个端口扫描工具，比如 NMAP、SUPERSCAN、SCANPORT、</p>
<p>SSPORT、TCPVIEW。</p>
<p>（2）扫描对方的主机，获得开放的端口号。捕获其所有相关信息和协议内容。显示过滤举例：</p>
<p>在这里，使用Zenmap对本机进行端口扫描，扫描结果如下图。</p>
<p><img src="/assets/clip_image019.jpg" alt="img"></p>
<p>可以看到，本机开放了6个端口，不同端口提供不同的服务，可以看到其中的80端口为Http服务，说明在本机上部署了自己的网站，用80作为端口。</p>
<p>查看Wireshark对该端口的抓包情况</p>
<p><img src="/assets/clip_image021.jpg" alt="img"></p>
<p>从图中看到两种协议，TCP和HTTP，这也印证了我之前部署网站的说法。</p>
<p>（3）关闭某一开放的端口，重新扫描，观察捕获效果。</p>
<p><img src="/assets/1542500979517.png" alt="1542500979517"></p>
<p>​       关闭端口后进行扫描，可以看到被关闭的端口扫描不到了。</p>
<p><strong>1.5</strong>  <strong>FTP</strong> <strong>协议包捕获与分析</strong></p>
<p>登录FTP 服务器：<a href="ftp://ftp.scene.org">ftp.scene.org</a>，重点捕获其 3 个关键过程：</p>
<p>（1）FTP 服务器的登录</p>
<p>捕获 USER 和 PWD 的内容，分析 FTP、TCP、IP 协议的首部信息。FTP 服务器的端口号为 21，用于控制连接。</p>
<p><img src="/assets/clip_image025.jpg" alt="img"></p>
<p>在这里使用的是filezilla登陆的FTP服务器，通过对登陆过程的捕获可以看到，登陆的账号为anonymous，密码为anonymous@example.com（默认）。</p>
<p>用Wireshark查看FTP、TCP、IP协议的首部信息，如下图。</p>
<p><img src="/assets/clip_image027.jpg" alt="img"></p>
<p>（2）FTP 文件的下载过程</p>
<p>要求分别下载三个大小不同的文件（小于 1MB、1MB—10MB、10MB 以上），观察 FTP、TCP 和 IP 协议中的数据分片过程。</p>
<p><img src="/assets/clip_image029.jpg" alt="img"></p>
<p>从图5-3中可以简单看出，下载文件的请求命令为”RETA ”，文件字节大小也不一样。</p>
<p>从发送时间也可以看出来一些差别。介于1MB—10MB的文件可能由于其格式或其他原因，没有正常显示出包的大小和传输时间。不过，通过对比不同的大小的文件，可以得出文件越大TCP切片长度越小，传输的字节越多，所用的传输时间越长。</p>
<p>（3）FTP 服务的退出过程</p>
<p>分析 FTP、TCP、IP 协议的不同内容。</p>
<p>FTP的退出过程在Wireshark的抓包过程中没有捕获到。</p>
<p><strong>1.6</strong>  <strong>HTTP</strong> <strong>协议包的捕获与分析</strong></p>
<p>登录到国内外的一些门户网站上，将主页浏览过程捕获下来，分析其 HTTP、TCP、UDP、</p>
<p>IP 协议的内容。注意 TCP 协议中的端口号。</p>
<p>补充一下HTTP的工作流程：</p>
<p>（1）    客户端通过TCP三次握手与服务器建立连接。</p>
<p>（2）    TCP建立连接成功后，向服务器发送http请求</p>
<p>（3）    服务器收到客户端的http请求后，将返回应答，并向客户端发送数据。</p>
<p>（4）    客户端通过TCP四次握手，与服务器断开TCP连接。</p>
<p>国内网站：</p>
<p><a href="http://xn--jd-8w2cqeqyvkx0nr7as7qkre3tc3w20amkf.com">国内这里以京东商城为列jd.com</a>（111.13.28.118），捕获主页浏览过程，抓包结果如图。从图中可以看出，No分别为1950、1951、1958时进行了TCP三次握手，此时使用的是TCP协议的80端口。（说明：Wireshark抓包仅限于http，对于https其无法解密识别，国内大部分网站主页都是http，只有在登陆界面或者少数主页是https加密，不过为了掩盖性，大部分网站的头部都以https开头，尽管他们没有发挥任何作用。）</p>
<p><img src="/assets/clip_image031.jpg" alt="img"></p>
<p><img src="/assets/clip_image033.jpg" alt="img"></p>
<p>从包的数据中可以分析得出(见图6-2)，本机地址10.10.215.246，捕获端口为19651。目标地址为111.13.28.118，开放端口为80，TCP协议数据切片长度为382。在看看HTTP协议，其中http请求头为Mozilla/5.0（Windows NT 10.0；Win64; X64）…以及它的接受语言为中文等等，是正常访问url时向服务器发送的一些数据信息。</p>
<p><strong>1.7</strong>  <strong>EMAIL</strong> <strong>协议包的捕获与分析</strong></p>
<p>登录到校内外的邮件系统，捕获自己的登录信息，重点分析其 SMTP、POP3 协议的内容。注意其端口号分别是 25 和 110。</p>
<p>国内外大部分邮箱采用ssl加密，即https协议，其中http常用端口为80，https常用端口号为443。下面我使用的是foxmail客户端来进行EMAIL协议包的捕获，捕获内容如下图</p>
<p><img src="/assets/image-20210826171426038.png" alt="image-20210826171426038"></p>
<p>在Protocol列中可以看到显示的协议有TCP和SMTP。由于SMTP是基于TCP协议的，所以在使用SMTP协议发送邮件之前，首先要通过TCP三次握手建立连接。从图中倒数第三个SMTP包的后面可以看到我发送邮件的邮箱账号。第75帧表示成功登陆邮箱，第78帧表示发送邮件的账户，本例中是A@qq.com。第81帧表示接受邮件的账户，本例中是B@qq.com。第83帧是客户端发送的内容，84帧使用<CR><LF>接收了文本的内容。</p>
<p><img src="/assets/image-20210826171603252.png" alt="image-20210826171603252"></p>
<p>该界面较为清晰的展示了邮件信息（右键一个SMTP包，选择follow-&gt;TCP Stream查看），红色部分为客户端发送的信息，蓝色部分是服务器相应信息。在该界面可以看到客户端的主机名、邮件账户、使用的邮件客户端、邮件内容类型和传输格式等等。也可以看见发送的信息内容，由于内容被转换为base64位格式的信息，进行了加密。</p>
<h2 id="四-思考题">四、 思考题</h2>
<p>（1）在 FTP 服务中，FTP 数据长度为什么是 1460 字节？</p>
<p>最大传输单元是1460字节是TCP层的报文段(segment)的长度限制。</p>
<p>（2）如何捕获 FTP 服务的结束数据包？</p>
<p>在过滤器中输入ftp，会看到在Information信息列中出现Request：QUIT的内容，表示为ftp的结束包</p>
<p>（3）在端口扫描中，对应的协议有 TCP 和 UDP。应该如何查找某端口对应的服务类型？</p>
<p>在cmd命令行中使用netstat -a -n命令查看。</p>
<p>（4）不指定 IP 地址时，为什么有的邻近主机捕获不到？</p>
<p>每个信息包能够通过网络不同的路径发送，信息包能按照与它们发送时的不同顺序到达。网络协议（IP）仅仅是递送他们，TCP才是能够将它们按照正确顺序组合回原样。IP是一个无连接协议，这就意味着在通信的终点之间没有连续的线路连接。这就导致了会有一些主机捕获不到信息。</p>
<p>（5）PING 命令操作时，为什么会捕获 ARP 协议的数据包？</p>
<p>因为ARP协议是“Address Resolution Protocol” 的缩写。在局域网中，网络中实际传输的是帧，帧里面是有目标主机的MAC地址的。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址以保证通信的顺利进行。</p>
<p>参考文章：</p>
<p><a href="https://jingyan.baidu.com/article/d621e8da0abd192865913f1f.html">如何关闭139端口及445端口等危险端口</a></p>
<p><a href="https://segmentfault.com/a/1190000006199237">聊一聊HTTPS那些事</a></p>
<p><a href="https://blog.csdn.net/lalalahaitang/article/details/81119336">TCP协议(1)–TCP首部</a></p>
<p><a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970">wireshark过滤规则及使用方法</a></p>
<p><a href="https://jingyan.baidu.com/article/c35dbcb0866b698916fcbc81.html">wireshark抓包教程</a></p>
<p><a href="https://www.cnblogs.com/superdo/p/4712787.html">电子邮件抓包分析</a></p>
]]></content>
      <tags>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网通信</title>
    <url>/2018/10/21/09LAN-Communicate/</url>
    <content><![CDATA[<p><img src="/images/communication.jpg" alt="cover"></p>
<a id="more"></a>
<h3 id="主机相互发送消息">主机相互发送消息</h3>
<h4 id="背景">背景</h4>
<p>本学期的计算机网络课非常有意思，它与我们的生活息息相关，曾经我也为电脑发生的网络问题而困惑，总是没有根据的瞎尝试来试图解决问题。但是在老师的一些简单指导之后，有了一个基本的ip之间通信以及局域网的概念。于是就想，既然局域网内部不用通过路由器就能发送数据，那我就可以给同学的电脑发消息了呀，带着这样的兴趣，我开始了本次尝试。</p>
<h4 id="发送消息">发送消息</h4>
<ol>
<li>关掉发送消息电脑及接受电脑360安全卫士等杀毒软件</li>
<li>关掉两电脑域防火墙、专用网络防火墙、公用网络防火墙等，如图1</li>
</ol>
<p><img src="/assets/1540101899894.png" alt="1540101899894"></p>
<ol start="3">
<li>打开控制面板-&gt;凭据管理器-&gt;Windows凭据<br>
单击添加Windows凭据，输入要连接的ip以及用户名密码（每台主机可以同时拥有多个用户，尽量不要用Adminsitrator用户）<br>
<img src="/assets/1540102133297.png" alt="1540102133297"></li>
<li>添加之后，点击确定即可。同时按住win+r打开运行界面，输入cmd后回车</li>
<li>在cmd命令行中输入<code>msg server:(ip) * &quot;消息内容&quot;</code>如下图所示<br>
<img src="/assets/1540102455111.png" alt="1540102455111"></li>
<li>目标电脑收到所发送的消息，如图<br>
<img src="/assets/1540102669781.png" alt="1540102669781"></li>
</ol>
<h4 id="可能存在的一些问题">可能存在的一些问题</h4>
<h5 id="获取会话名称时的错误1722">获取会话名称时的错误1722</h5>
<p>这种情况说明RPC服务器不可用，win+r运行regedit.exe，找到&quot;计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot;把AllowRemoteRPC的值从0改为1就能接受信息了。</p>
<h5 id="获取会话名称时的错误5">获取会话名称时的错误5</h5>
<p>尝试以管理员身份运行cmd，或者就是没有添加用户凭据，或者是用户凭据添加出错了，重新添加一下用户凭据</p>
<h3 id="参考文献">参考文献</h3>
<ol>
<li><a href="https://www.cnblogs.com/mq0036/p/3574555.html">MSG命令使用详解</a></li>
<li><a href="http://codewa.com/question/70756.html">错误：1722获取会话名称l</a></li>
<li><a href="https://blog.csdn.net/qq_24264221/article/details/70980123">错误：5获取会话名称</a></li>
</ol>
]]></content>
      <categories>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>局域网通信</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机院校信息整合</title>
    <url>/2018/09/28/08Graduate-School/</url>
    <content><![CDATA[<p><img src="/images/schoolChoice.jpg" alt="cover"></p>
<a id="more"></a>
<h3 id="北京航空航天大学计算机学院招生">北京航空航天大学计算机学院招生</h3>
<h4 id="招生简章-2019年">招生简章(2019年)</h4>
<p>北航计算机学院推免生招生情况</p>
<p><img src="/assets/%E5%8C%97%E8%88%AA%E6%8E%A8%E5%85%8D%E7%94%9F.png" alt="北航推免生"></p>
<p>201803统考硕士招生情况</p>
<p>全日制学硕：54人，其中计算机科学与技术38人，软件工程7人，网络空间安全9人</p>
<p>全日制专硕：123人</p>
<p>非全日制专硕：53人</p>
<h4 id="考研大纲">考研大纲</h4>
<p>961计算机基础综合共包括三门课程的内容：计算机组成原理、操作系统、计算机网络技术，分别占60分，50分、40分。所有课程均不指定参考书。具体要求见<a href="http://scse.buaa.edu.cn/info/1102/5423.htm">北航研究生入学专业课考试大纲</a></p>
<h4 id="联系方式">联系方式</h4>
<p>北航研究生招生办公室（学历硕士）办公地址：北航行政办公楼东楼二层。</p>
<p>联系电话：010-82317637传真电话：010-82328059</p>
<p>E-mail: <a href="mailto:yzb@buaa.edu.cn">yzb@buaa.edu.cn</a></p>
<p>微信号：buaayzb</p>
<h3 id="北京邮电大学计算机招生">北京邮电大学计算机招生</h3>
<p>主要参考<a href="https://ningzimu.github.io/See_you_in_BUPT/#%E6%8B%9B%E7%94%9F%E4%B8%93%E4%B8%9A%E7%9B%AE%E5%BD%95">北邮考研相关信息查阅宝典</a></p>
<h4 id="2019年硕士研究生硕士专业目录-计算机学院"><a href="https://yzb.bupt.edu.cn/content/content.php?p=8_4_67">2019年硕士研究生硕士专业目录(计算机学院)</a></h4>
<p>推免生比例不超过50%。</p>
<p>计算机学院招生408人，其中计算机科学与技术118人、智能科学与技术12人、计算机技术278人(专业学位，含180非全日制)</p>
<h4 id="考研大纲">考研大纲</h4>
<p><a href="https://yzb.bupt.edu.cn/content/content.php?p=8_4_269">803计算机学科基础综合</a></p>
<h4 id="往年报考录取情况"><a href="https://yzb.bupt.edu.cn/list/list.php?p=3_22_1">往年报考录取情况</a></h4>
<p>2017</p>
<p><img src="/assets/2017%E5%8C%97%E9%82%AE.png" alt="2017北邮"></p>
<h3 id="北京大学计算机招生2018">北京大学计算机招生2018</h3>
<p>2018专业目录</p>
<h4 id="信科">信科</h4>
<p><img src="/assets/1547376642700.png" alt="1547376642700"></p>
<h4 id="软件与微电子学院">软件与微电子学院</h4>
<p><img src="/assets/1547344481109.png" alt="1547344481109"></p>
<p>软微对比信科优势如下，学费较贵，3年6万</p>
<p><img src="/assets/1547376711834.png" alt="1547376711834"></p>
<p><img src="/assets/1547377172407.png" alt="1547377172407"></p>
<p>18年招了119人，19年计算机技术方向预估150来人</p>
<p><img src="/assets/1547377358782.png" alt="1547377358782"></p>
<p><img src="/assets/1547377638493.png" alt="1547377638493"></p>
<h5 id="复习规划">复习规划</h5>
<p>​	不用看慕课、不用看网上流传的各种视频、不用花钱买北大ppt</p>
<p>只用看书+做题，书指的是王道的单科书或天勤的单科书。</p>
<p><strong>考试科目</strong>：数据结构、计算机网络、操作系统</p>
<p><strong>适用专业</strong>：软件工程专硕、计算机技术中的技术类</p>
<p><strong>获取地点</strong> ：王道论坛经验帖、备考软微的QQ群</p>
<p><strong>题目特点</strong>：18年变化比较大，模拟卷做到原题</p>
<p>30到选择题，每科10题，每题2分（共60分）</p>
<p>9道大题，每科3题，每题10-20分（共90分）</p>
<p>大题每年都会有变动</p>
<p><strong>策略</strong>：单科书一定要反复多次全面</p>
<p>第一遍做题建议所有题都做，错的标记，第二次做再标记。第三次只做错题</p>
<p>边回忆边做总结笔记和高频错题，采用索引结构不用全记</p>
<p>后期做真题（王道难度完全超过真题难度），记得总结，水题考前突击。</p>
<p>考前把自己做过的笔记错题拿出来反复看。可能考算法</p>
<p>408真题不需要看，王道很多题就是408的题，科班直接看两边</p>
<p><strong>复试</strong> 双非歧视?三跨生不要？往届生吃亏？学长三重身份。。。</p>
<p>王道者？初始分高者也！</p>
<p>政治抱好肖老师大腿。</p>
<p>录取之后第一周可以转方向，没有四六级要求</p>
<p>学长在复试的时候没有机试，开学的时候增加机试，没过的话增加一门语言课。软工4万，计算机6万，都是3年。</p>
<p>并且北大的专硕还可以正常申请读博士，提前联系好导师。</p>
<p>学长复习早上6点，晚上到11点</p>
<p>软微是开学导师双选，你提前联系导师对你复试毫无帮助，不如好好准备复试。</p>
<p>软微9月份公布参考书目，9月份之前完成一轮复习</p>
<p><img src="/assets/1547383663254.png" alt="1547383663254"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新的基于小阴影图像的彩色图像秘密共享方案</title>
    <url>/2018/09/03/06URT-ScienceDirect/</url>
    <content><![CDATA[<p><img src="/images/secretImage.jpg" alt="cover"></p>
<a id="more"></a>
<hr>
<h3 id="摘要">摘要</h3>
<p>在过去几年，秘密图像分存技术变成了除了传统密码学的另一个努力的方向去防止秘密图像被窃取。由于小的影子图像可以加快秘密颜色图像的传播，在这篇文章中我们结合了Chang和Wu的单位图BTC（GSBTC）的渐进式搜索算法和Shamir的（k,n）门限概念提出一种新的秘密彩色图像共享方案来生成更小的影子。实验结果证实了提出的架构成功减小了影子的大小，并且每个影子表现为一个随机类的图像，这个图像能防止秘密彩色图像的信息泄露。此外，每个影子中两个纵向或横向相邻像素的关联性明显小于秘密彩色图像。提出的方案也实现了，平均来看，NPCR值为0.414%、AUCI值为32.78%。因此，在我们的方案中，一个像素差异会导致相应阴影的显著差异。因此，该方案的安全性也得到了证实。</p>
<h3 id="介绍">介绍</h3>
<p>随着电脑技术的成长，数字相机之类的多媒体变得越来越受欢迎，使得越来越多的数字图像在网上广泛的分享和传播。然而，在网上传输那些秘密或者重要的图像，例如被用于军事或者企业重要秘密图像，则面临一定的危险。恶意的人监视互联网并试图检测并获取这些有价值的图像。为了使这些传输图像免于获取或篡改，秘密分寸技术提出了继传统密码学和隐写术之外的一个新的分支来从掠夺行为中保护重要图像。在这个秘密共享技术后的概念，也叫做（k，n）门限方案，它是Blakley和Shamir独立提出的。这些（k，n）门限方案有三个性质。</p>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>时 ：<br>
（1）：这个秘密图像可以被分成n个部分<br>
（2）：任意k或者大于k个部分都能恢复秘密图像<br>
（3）：任意k - 1 或者小于k个部分不能计算秘密值<br>
Naor和Shamir在1995年第一次使用(k, n)门限方案介绍了聚焦于图像数据的秘密图像共享技术。本质上，秘密图像分存技术使用了几个随机性的被称为影子的图像来代替原始图像在网络上传输数据。影子可以阻挡恶意的攻击者并防止秘密图像被直接访问。秘密共享方案继承了(k, n)门限方案的三个属性。</p>
<p>在过去十年里，许多秘密共享方案被提出。它们有一个共同的特点，即秘密图像可以通过叠加阴影来恢复，换句话说，这些秘密图像可以很容易地恢复，而无需复杂的计算。然而，在这些方案中，阴影的大小通常大于或等于秘密图像的大小。已经提出了许多方案来克服这个问题。在2002，Thien和Lin提出了一种生成更小阴影的（k，n）秘密图像共享方案。他们的方案通过将K - 1作为K像素的灰度值和模251来生成K—1度多项式。通过模251，它们截断大于250的所有灰度值，这导致将所有秘密图像灰度值连接至0-250范围。然后使用Akey生成一个置换序列来置乱秘密图像的像素，从而隐藏相邻像素之间的任一相关性。然后，对秘密图像的k个非共享像素进行采集，成为k  - 1次多项式的k个系数。这些系数和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次多项式为n个阴影图像生成n个像素，直到对秘密图像中的所有像素进行处理。使用此过程，Thien和Lin成功地将每个阴影的大小减小到秘密图像的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>大小。</p>
<p>受Thien和Lin的启发，Wang和Su后来设计了一个秘密图像共享方案，改进了Thien和Lin的方案。首先，它们的方案生成一个t比特秘密图像的二值图像。接着，利用Huffman编码对二值图像进行编码，得到的t比特形成共享码。然后，<br>
k共享系数用作k -1次多项式共享函数的共享系数，直到处理完所有的Huffman编码结果。用Wangf和Su的方案进行的实验表明，生成的阴影小于Thien和Lin的阴影。然而，两种方案都不能直接应用于彩色图像，因为生成的彩色阴影的大小是灰度阴影的三倍。</p>
<p>由于秘密图像可能是彩色图像，本文提出了一种有损秘密彩色图像共享方案，扩展了秘密图像共享的应用。在我们的方案中，阴影的大小取决于K的数量和较大的K产生较小的阴影。实验结果表明，该方案能有效地减小阴影的大小。本文的其余部分整理如下。第2节包含了（k，n）门限方案和GSBTC的简要回顾。第3节详细介绍了我们的方案。第4节给出了实验结果，并对所提出的方案进行了统计分析和安全性分析。在第5节中描述了未来的工作和一些结论。</p>
<h3 id="相关工作">相关工作</h3>
<p>采用两个重要的技术来设计我们的方案：（k，n）门限方案和GSBTC。前者允许将一个秘密图像分解成n个阴影图像，仅需要k个阴影来构造原始秘密图像。后者可以将一个秘密的彩色图像压缩成更小的尺寸，并具有可接受的失真。换言之，通过采用(k，n)阈值方案和GSBTC，可以克服数据传输过程中的潜在损耗，并且可以成功地减小阴影大小。为了给出所提出的方案的背景知识，这些技术在以下各节中说明</p>
<h4 id="基于多项式插值的shamir-k-n-门限方案">基于多项式插值的Shamir（k，n）门限方案</h4>
<p>1979，Shamir提出了一种基于多项式插值的（k，n）门限方案。他的方案假定数据D被分成n个片段D1，D2，.…D n，并且仅需要任何D的k个部分，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，才能重建原始秘密数据D。因此，如果仅接收（k  - 1）或小于（k -1）个片段，则仍然不能显示秘密数据D。</p>
<p>假设秘密数据D是一个数字。在Shamir的方案中，素数g是随机选择的，K - 1的多项式分担函数是在等式（1）中被划分为N个阴影。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mo>…</mo><mo>…</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">f(x) = (a_0 + a_1x + ……+a_{k-1}x_{k-1})\%g
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span></span></p>
<p>其中a<sub>1</sub>，a<sub>2</sub>，……a<sub>k - 1</sub>都是随机数，并且a<sub>0</sub>=D。i＝1～n的每个D<sub>i</sub>可由方程导出。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i = f(i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中i＝1 -n，并且每一个D1，D2，。…Dn被视为阴影。为了获得秘密数据D，D<sub>i</sub>的任何k个或更多阴影可以重构f（x）。多项式函数f(x)的所有系数可由拉格朗日插值公式导出，并可计算秘密数据D=a0=f(0)。</p>
<p>本文提出的秘密彩色图像共享方案基于Shamir(k，n)阈值方案，使得秘密图像D被划分为n个阴影(D1，D2，.…，Dn）然而，在所提出的方案中，每份的大小随着分享数量的增加而减少。</p>
<h4 id="一个单位图btc的渐进搜索算法">一个单位图BTC的渐进搜索算法</h4>
<p>在采用Shamir（k，n）阈值方案将一个秘密图像分割成若干个阴影以克服数据传输过程中可能出现的任何损失之前，我们需要解决另一个问题，即如何减小原始彩色图像的大小，从而减小阴影大小。Chang和Wu设计的一个单位图BTC（GSBTC）的渐进搜索算法是我们的解决方案。块截断编码（BTC）变体GSBTC是一种简单而简单的彩色图像压缩算法。</p>
<p>在传统BTC中，图像首先被分成几个非重叠的方块，每个块可以是4×4、8×8等。然后计算每个块的平均像素值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。一般来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>是量化阈值。在块中，将每个像素值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>进行比较，从而生成由两个组组成的位图。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>&lt;</mo><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bar{x}&lt;X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.60688em;vertical-align:-0.0391em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则位图中的相应位属于组-1，表示为“1”；否则，该位属于组-0，表示为“0”。虽然BTC被设计为压缩灰度图像而不是彩色图像，但同样的过程可以应用于彩色图像。不幸的是，压缩比不是。当使用BTC压缩彩色图像时，也是如此，因为彩色图像由三个平面R、G和B组成，并且当使用BTC时，这三个平面形成三个位图。</p>
<p>为了提高彩色图像中的BTC压缩比，通常的方法是生成一个公共位图，该位图使三个单独的位图的失真最小。然而，设计一个生成一个公共位图的算法是一个很难的问题。Chang和Wu的GSBTC算法生成一个等价的公共位图，该位图在保持低计算复杂度的同时，提供解压缩图像的可接受的图像质量。在本文中，我们使用GSBTC对秘密彩色图像进行压缩，然后给出一个秘密图像。有损秘密彩色图像共享方案。为了更好地解释我们提出的方案，我们首先在以下段落中详细介绍Chang和Wu的GSBTC算法。</p>
]]></content>
  </entry>
  <entry>
    <title>pyecharts可视化学生信息</title>
    <url>/2018/09/02/05Pyecharts/</url>
    <content><![CDATA[<p><img src="/images/pyechart.gif" alt="cover"></p>
<a id="more"></a>
<h2 id="介绍">介绍</h2>
<hr>
<p>pyecharts是python的一个包，里面封装了echarts的接口，而echarts是一个功能非常强大的绘图工具，图形非常简洁、美观。相比于matplotlib还是有很多优势的，比如echarts的交互功能。如图：<br>
<img src="https://user-images.githubusercontent.com/19553554/35104157-fa39e170-fca2-11e7-9738-1547e22914a6.gif" alt="动画演示"></p>
<p><img src="%5Cimg%5Cpyecharts%5Cpyecharts.gif" alt="pyecharts"></p>
<p>所以它可以用来演示功能、或者数据分析报告等等。</p>
<h2 id="加载数据集">加载数据集</h2>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.read_csv(<span class="string">&quot;Student Info.csv&quot;</span>) <span class="comment">#读取csv文件</span></span><br><span class="line">df.info()  <span class="comment">#查看学生各个属性有无缺失值</span></span><br></pre></td></tr></table></figure>
<h2 id="数据清洗">数据清洗</h2>
<hr>
<p>在加载到数据集之后，我们首先统计一下学生的生源地分布情况。要统计生源地情况，即我们要得到两个列表，第一个为各省份名称，第二个列表为对应名称在数据集中出现的次数(频率)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">region_num = df[<span class="string">&#x27;生源地&#x27;</span>].value_counts() <span class="comment">#统计各类别频率</span></span><br><span class="line">region_num = region_num.values.tolist() <span class="comment">#将频率转换为列表</span></span><br><span class="line">region = df[<span class="string">&#x27;生源地&#x27;</span>].value_counts().keys() <span class="comment">#统计各类别频率对应的键值</span></span><br><span class="line">region = region.values.tolist() <span class="comment">#将键值转换为列表</span></span><br><span class="line">print(region_num) <span class="comment">#打印频率查看</span></span><br><span class="line">print(region)  <span class="comment">#打印地区查看</span></span><br></pre></td></tr></table></figure>
<h2 id="绘图-柱状图-地域">绘图-柱状图-地域</h2>
<hr>
<p>我们用pyecharts的柱状图来绘制图形，同时将上面得到的region_num和region作为参数传到绘图函数中。在这里add采用了多个参数，如无需要可以去掉。</p>
<blockquote>
<ul>
<li><code>add()</code><br>
主要方法，用于添加图表的数据和设置各种配置项</li>
<li><code>print_echarts_options()</code><br>
打印输出图表的所有配置项</li>
<li><code>render()</code><br>
默认将会在根目录下生成一个 render.html 的文件，支持 path 参数，设置文件保存位置，如 render(r&quot;e:\my_first_chart.html&quot;)，文件用浏览器打开。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar <span class="comment">#引用直方图</span></span><br><span class="line">bar = Bar(<span class="string">&quot;信息工程学院&quot;</span>,<span class="string">&quot;信息2018级新生生源地统计&quot;</span>,width=<span class="number">1000</span>, height = <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">bar.use_theme(<span class="string">&#x27;dark&#x27;</span>)  <span class="comment">#背景主题</span></span><br><span class="line"></span><br><span class="line">bar.add(<span class="string">&quot;生源地&quot;</span>, region, region_num, is_stack=<span class="literal">False</span>, bar_category_gap=<span class="string">&#x27;20%&#x27;</span>,xaxis_interval =<span class="number">0</span>,xaxis_rotate=<span class="number">20</span>, is_more_utils=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bar.render() #导出为网页</span></span><br><span class="line">bar <span class="comment">#查看</span></span><br></pre></td></tr></table></figure>
<p>通过以上步骤就能看到如下图所示结果</p>
<p><img src="%5Cimg%5Cpyecharts%5Cpyecharts01.png" alt="pyecharts01"></p>
<h2 id="绘图-饼图-第一志愿">绘图-饼图-第一志愿</h2>
<p>同样要先进行数据清洗，查看有无缺失值</p>
<p><img src="%5Cimg%5Cpyecharts%5Cpyecharts02.png" alt="pyecharts02"></p>
<p>可以看到，第一志愿数据是不全的，需要进行缺失值处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">choice = df[<span class="string">&#x27;第一志愿&#x27;</span>].fillna(<span class="string">&#x27;&#x27;</span>) <span class="comment">#缺失值填充为空</span></span><br><span class="line">volunteer_first_num = df[<span class="string">&#x27;第一志愿&#x27;</span>].value_counts() <span class="comment">#统计各类别频率</span></span><br><span class="line">volunteer_first_num = region_num.values.tolist() <span class="comment">#将频率转换为列表</span></span><br><span class="line">volunteer_first = df[<span class="string">&#x27;第一志愿&#x27;</span>].value_counts().keys() <span class="comment">#统计各类别频率对应的键值</span></span><br><span class="line">volunteer_first = region.values.tolist() <span class="comment">#将键值转换为列表</span></span><br><span class="line">print(volunteer_first_num) <span class="comment">#打印频率查看</span></span><br><span class="line">print(volunteer_first)  <span class="comment">#打印地区查看</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>
<p>name -&gt; str<br>
图例名称</p>
</li>
<li>
<p>attr -&gt; list<br>
属性名称</p>
</li>
<li>
<p>value -&gt; list<br>
属性所对应的值</p>
</li>
<li>
<p>radius -&gt; list<br>
饼图的半径，数组的第一项是内半径，第二项是外半径，默认为 [0, 75]<br>
默认设置成百分比，相对于容器高宽中较小的一项的一半</p>
</li>
<li>
<p>center -&gt; list<br>
饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标，默认为 [50, 50]<br>
默认设置成百分比，设置成百分比时第一项是相对于容器宽度，第二项是相对于容器高度</p>
</li>
<li>
<p>rosetype -&gt; str</p>
<p>是否展示成南丁格尔图，通过半径区分数据大小，有’radius’和’area’两种模式。默认为’radius’</p>
<ul>
<li>radius：扇区圆心角展现数据的百分比，半径展现数据的大小</li>
<li>area：所有扇区圆心角相同，仅通过半径展现数据大小</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Pie <span class="comment">#饼图</span></span><br><span class="line"></span><br><span class="line">pie = Pie(<span class="string">&quot;第一志愿&quot;</span>) <span class="comment">#标题</span></span><br><span class="line"></span><br><span class="line">pie.add(<span class="string">&quot;&quot;</span>, choice, choice_num, radius=[<span class="number">30</span>, <span class="number">75</span>], is_legend_show=<span class="literal">False</span>, is_label_show=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#radius半径范围</span></span><br><span class="line"><span class="comment">#is_legend_show是否显示图例</span></span><br><span class="line"><span class="comment">#is_label_show是否显示标签</span></span><br><span class="line">pie</span><br></pre></td></tr></table></figure>
<p><img src="%5Cimg%5Cpyecharts%5Cpyecharts03.png" alt="pyecharts03"></p>
<h2 id="总结">总结</h2>
<p>以上就是我对pyecharts的简单使用以及探索，在这个过程中我发现参阅文档是极其重要的，在网上闷着头找解决方案不如认真仔细的读一读<a href="http://pyecharts.org/#/zh-cn/prepare">pyecharts文档</a> ，里面绝对有你想要找的地方，起初我是找一个字体倾斜的解决方案，找了半天，给的都不是特别全面，在看了文档之后才发现，许多问题作者都是考虑在内了的，这会让你事半功倍。而且，pyecharts的封装是由我们国人完成的，文档阅读起来非常方便，所以必须支持下。</p>
]]></content>
      <categories>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>北京林业大学-掌上医生APP开发</title>
    <url>/2018/08/09/03App-Paldoctor/</url>
    <content><![CDATA[<p><img src="/images/PalDoctor.jpg" alt="cover"></p>
<a id="more"></a>
<h1>前言</h1>
<p>这个项目由来来的比较有意思，通过曾经在爱未来指导我的老师，我与北京工业大学以宫明昊为队长的小队走到了一块。起初是想在暑假找份实习，通过王帅老师投了两份，没反应，就把此次项目当作一份实习了，同时也接触一下其他学校的学生。团队中只有我一个人负责APP的开发，让第一次接触211学校同学的我有些压力。</p>
<h1>项目信息</h1>
<p>2018年7月中旬，组内开了第一次会，整体了解了一下项目背景、项目制作初衷以及小组成员的工作分配。这个项目，主要针对互联网+创新类比赛，而且已经拿到了专利并获得比赛创办者的支持。 我还是第一次接触到这么优秀的项目，因此在我跟队长宫明昊谈完之后，我就决定做好它了。</p>
<p>紧接着项目指导老师在北京林业大学工学院实验楼给各小队成员开了一个会议，会议上老师对各小组的工作提出了要求，同时也对比赛的进行做了介绍，之后，我就要正式开始我的工作了。</p>
<h1>项目开展</h1>
<p>前期队里其他成员已经将他们设计好的界面图发到群里了，我只需要一个个实现就行了。</p>
<h2 id="项目的开发环境">项目的开发环境</h2>
<p>Windows10，软件为andorid studio3.1.0，数据库使用android studio自带的sqlite</p>
<h2 id="项目基础页面设计">项目基础页面设计</h2>
<p>项目前期设计的还算比较顺利，完成立一系列的的界面设计，同时以易通行app做参照，在界面设计方面有所提高，学会了利用分割线来设计界面。其他的都是一些基础设计，具体设计如下图<br>
<img src="/img/paldoctor/selfInfo.jpg" alt="Alt text"><br>
<img src="/img/paldoctor/login2.jpg" alt="Alt text"><br>
不过跟我们生活中用的APP比起来，简直LOW到爆了，还要很多东西要去学习。</p>
<h2 id="短信验证码的实现">短信验证码的实现</h2>
<p>在设计注册界面时按照需求通过给手机发送短信验证码，从而进行注册</p>
<p>面向用户的话，为了安全性的考量，应该是通过给短信验证码平台发送消息，再有验证码平台对移动商服务器请求，最后手机才收到短信。而这里就是用简单生成的六位随机数来模拟验证码，同时调用手机的短信服务接口，来进行短信的发送。</p>
<p><img src="/img/paldoctor/login1.jpg" alt="Alt text"></p>
<h2 id="上传本地文件到服务器">上传本地文件到服务器</h2>
<p>在进行上传时，涉及到很多盲区，包括网络传输协议、网络信息发送方式、java输入输出流、java的多线程以及阿里云服务器的使用。这个过程我主要时通过以下拆分来完成的<br>
<img src="/img/paldoctor/process.png" alt="Alt text"></p>
<p>起初我大致了解了Android通信的几种方式socket(套接字),Internet协议、常见Http处理等</p>
<p>从java端到java端并没有什么难度，网上也给出了很多的经典例子。因此开始我就忽略了对java流实现的研究，直接进行文件的发送。开始还比较顺利，可是到了阿里服务器就坏了，通过对服务器Ubuntu的命令始终无法打开其端口，最终通过登陆阿里云平台的开放端口，最终才实现文件的发送。这一问题解决，其他就顺利的实现了手机端到服务器文件的发送。</p>
<h2 id="下载服务器文件到本地">下载服务器文件到本地</h2>
<p>在网上并没有对应上传下载同时进行，而只开一个端口的操作。于是自己看了一下java的IO流操作。<br>
主要有Output、Input、Writer和Reader。其他的FileInput之类的属于从这些基类上派生出来的具体的操作。</p>
<p>我主要使用Output及Input来分别操控四个地方的文件即手机本地文件、android读取到平台的流文件、android收到的流文件、服务器本地文件</p>
<p>通过socket+服务器tmux+android流+线程的组合，顺利实现了下载。</p>
<p>不过还遗留了一个问题，就是不知道如何去断开流之间文件的读取，因此目前APP每次就只能下载一个服务器文件到本地<br>
<img src="/img/paldoctor/tmux.png" alt="Alt text"><br>
tmux 命令<br>
<code>tmux attach</code> 切换到后台<br>
ctrl + b + d  后台执行并切换到前台</p>
<h2 id="上传头像">上传头像</h2>
<p>头像的上传让我对startactivityforresult的理解又更深了一步，能够灵活通过request和result来区分不同的任务。用户在选择头像时，首先会弹出对话框(AlertDialog)选择上传方式。选择拍摄会直接调用相机的接口，跳转到拍摄界面。选择从文件中选择则直接跳转到相册。</p>
<p>在拍完照或者选择完图片之后会有一个方形区域来选择呈现的部分。而这个部分作为Bitmap返回到主界面forresult函数进行操作(保存到本地以及显示在界面上)。</p>
<p><img src="/img/paldoctor/pt.jpg" alt="Alt text"><img src="/img/paldoctor/ptchose.jpg" alt="Alt text"></p>
<p>ps:这里的上传指的是将裁剪后的图片保存到本地路径，从而在该用户第二次登陆时能够加载历史头像。</p>
<h1>总结</h1>
<p>以上就是掌上医生比赛项目的内容及制作过程，虽然有一些经验并且有参考，不过这次也确实学到了很多知识。首先，在对网络一片空白的情况下去研究 <strong>socket+服务器tmux+android流+线程</strong>这一套东西，并且能坚持下来，这其中也是非常锻炼人，还好我没有放弃这一块。</p>
<p>在这次实战中，我接触到了很多网络方面的知识，我觉得非常有意思，我们平时打开的网页也是对服务器的一次次请求，不过他们的通信又是另一种方式了。我对服务器、客户端有了一个新的认识，同时也对自己有了一个新的认识。无论是adnroid接口、andorid界面，还是socket通信、服务器命令等等，还有非常多的盲区，还要很多可以进步的地方，希望以后能越来越棒！</p>
<p>最后附上源码地址<a href="https://github.com/YuleZhang/PalDoctor">https://github.com/YuleZhang/PalDoctor</a></p>
]]></content>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title>个人收藏</title>
    <url>/2018/08/07/01self-collection/</url>
    <content><![CDATA[<p><img src="/images/welcome-cover.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="近期workshop-for-qml">近期Workshop for QML</h2>
<p>11月23日天津大学研讨会</p>
<p><a href="https://tensorworkshop.github.io/NeurIPS2020/">12月份NeurIPS 2020</a></p>
<p><a href="https://tensorworkshop.github.io/2020/index.html">2021年1月IJCAI-2020</a></p>
<h2 id="优质视频学习资源">优质视频学习资源</h2>
<p><a href="https://www.icourse163.org/">中国大学MOOC</a>能较为方便的查看国内知名高校开设的课程，适合学一些比较系统的知识、架构或者涉足新领域</p>
<p><a href="http://www.feemic.cn/mooc">幕课视频搜索解析工具</a>是上述进阶版，可以查看下载关闭学期的课程</p>
<p><a href="https://www.imooc.com/course/list">慕课网免费课程</a> 比较全面cs课程网站</p>
<p><a href="https://www.zhihu.com/question/29748492">可选择资源1</a>来自于知乎，推荐了较多的视频学习网站，待探索</p>
<p><a href="https://mp.weixin.qq.com/s/Ft7TmbTPVRK1_9x-6iE17w">可选择资源2</a>来自于微信文都的一篇文章，收录了全球比较好的视频学习网站。</p>
<!-- more -->
<h2 id="机器学习">机器学习</h2>
<p><a href="https://www.leiphone.com/news/201610/Oqndr7PXFB9BRI9p.html">入门必备</a>机器学习视频推荐<br>
<a href="https://zhuanlan.zhihu.com/p/26169982">机器学习自学指南</a></p>
<p><a href="http://blog.jobbole.com/112569/">机器学习实践指南</a></p>
<p><a href="http://www.360doc.com/content/17/0417/14/20558639_646290956.shtml">kaggle入门详细教程</a>给出了具体步骤，附带资源链接</p>
<p><a href="https://colab.research.google.com/notebooks/intro.ipynb#recent=true">Colab算力(免费Tesla P4)</a></p>
<p><a href="https://matpool.com/host-market">矩池云(3块一小时的2080 Ti)</a></p>
<h2 id="算法学习">算法学习</h2>
<p><a href="https://www.cnblogs.com/yinbiao/">常见算法及数据结构总结</a></p>
<h2 id="ppt免费资源">PPT免费资源</h2>
<p><a href="http://www.1ppt.com/moban/jingdian/">第一PPT模板免费下载</a>PPT资源比较丰富</p>
<h2 id="思维导图-流程图">思维导图、流程图</h2>
<p><a href="https://www.processon.com/">ProcessOn</a>在线编辑工,方便的进行流程图的制作，无广告</p>
<h2 id="图片素材">图片素材</h2>
<h3 id="工程矢量图">工程矢量图</h3>
<p><a href="http://iconfont.cn/">阿里矢量图</a> 包含大量的小图标</p>
<p><a href="https://www.easyicon.net/">easyicon素材库</a></p>
<p><a href="https://blog.csdn.net/weixin_42474261/article/details/106711403">逗比拯救世界</a> 表情包搜索网站</p>
<h3 id="其他">其他</h3>
<p><a href="https://picjumbo.com/">picjumbo</a> 博客专用高品质大图1</p>
<p><a href="https://www.lifeofpix.com/">lifeofpix</a> 博客专用高像素大图 2</p>
<p><a href="https://pixabay">pixapay</a>  高清无版权图片库</p>
<p><a href="https://www.pexels.com/">pexels</a> 英文搜索</p>
<p><a href="http://thestocks.im/">thestocks</a> 无版权图片库资源整合</p>
<h2 id="研究生参考资源">研究生参考资源</h2>
<h3 id="院校选择">院校选择</h3>
<p><a href="https://blog.csdn.net/cuijie0197/article/details/79394746">人工智能院校及导师等排名</a><br>
<a href="http://www.cdgdc.edu.cn/xwyyjsjyxx/xkpgjg/">全国第四轮学科评估</a></p>
<h2 id="代码在线生成url">代码在线生成url</h2>
<p><a href="https://paste.ubuntu.com">https://paste.ubuntu.com</a></p>
<h2 id="python库文档">python库文档</h2>
<p><a href="http://pyecharts.org/#/">pytcharts</a></p>
<h2 id="科学上网资源">科学上网资源</h2>
<p><a href="https://www.ali-sub.xyz/user">alisub付费梯子</a>，便宜稳定，本人在用（1块1G可叠加）</p>
<p><a href="https://hh2h.xyz/top.html">免费、付费科学上网VPN排行榜</a></p>
<p><a href="https://hh2h.xyz/53.html">VyprVPN手机电脑 不限流量不限速</a></p>
<p><a href="https://hh2h.xyz/408.html">SSR酸酸乳</a></p>
<h2 id="小工具">小工具</h2>
<p><a href="https://smallpdf.com/">word、pdf等文件在线转换</a></p>
<p><a href="http://www.jasondavies.com/wordcloud/">在线词云</a><br>
<a href="https://www.youtuhi.com/">优兔下载</a><br>
<a href="http://xueshu.baidu.com/usercenter/papercheck/">论文查重</a><br>
<a href="https://minhaskamal.github.io/DownGit/#/home">DownGit</a> 在github上下载单个子文件夹<br>
<a href="http://kagent.applinzi.com/qqun">QQ群爬虫</a><br>
<a href="https://blog.csdn.net/ww122081351/article/details/43485165">提取qq成员信息记录</a>是控制台脚本<br>
<a href="http://www.zhaowenku.com/">百度文库文章免费下载</a><br>
<a href="https://www.cnblogs.com/L-zhihua/p/6232354.html">U盘EXE病毒</a><br>
<a href="https://zhidao.baidu.com/question/272763300.html">清除C盘临时文件bat指令</a><br>
<a href="http://music.vm82.com/">多平台音乐免费下载</a><br>
<a href="https://pdfcrowd.com/">pdfcrowd</a>、<a href="https://www.web2pdfconvert.com/to/jpg">web2pdfconvert</a>、<a href="https://www.url2png.com/">url2png</a>：页面转PDF|PNG|JPG的API<br>
百度网盘倍速:videojs.getPlayers(“video-player”).html5player.tech_.setPlaybackRate(1.5)<br>
倍速播放js脚本:document.getElementsByClassName(‘uplayer_video’).playbackRate = 1.25<br>
慕课平台自动暂停破解js脚本:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;xt_video_player_play_btn fl&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">if</span> (a.className == <span class="string">&#x27;xt_video_player_play_btn fl&#x27;</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;检测到暂停，已继续&#x27;</span>);</span><br><span class="line">     a.click();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;视频正在播放&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="电影">电影</h2>
<h3 id="未看">未看</h3>
<p><a href="http://t.cn/ReSIUiU">西虹市首富（高清）</a>    <a href="http://t.cn/ReSIfvY">邪不压正</a></p>
<h3 id="已看">已看</h3>
<p>碟中谍<br>
速度与激情<br>
暗战<br>
给爸爸的信<br>
西虹市首富<br>
我不是药神<br>
风雨咒<br>
情圣<br>
三傻大闹宝莱坞<br>
未知死亡<br>
喜剧之王<br>
摔跤吧！爸爸<br>
寻找幸福的赫克托</p>
<p>大鱼海棠</p>
<p>​          <a href="https://www.iqiyi.com/v_19rrho3enw.html">人生遥控器</a>        <a href="https://v.qq.com/x/cover/x5ul2annjsbcwh8/e00335q391x.html?ptag=iqiyi">三傻大闹宝莱坞</a></p>
<p><img src="http://pic3.iqiyipic.com/image/20190808/2f/69/v_62644868_m_601_m5_180_236.jpg" alt="人生遥控器"><img src="http://pic6.iqiyipic.com/image/20180212/0d/df/v_50215691_m_601_m7_180_236.jpg" alt="三傻大闹宝莱坞"></p>
]]></content>
  </entry>
  <entry>
    <title>第一次建网站</title>
    <url>/2018/08/07/02Blog-Build/</url>
    <content><![CDATA[<p><img src="/images/buildWebsites.jpg" alt="cover"></p>
<a id="more"></a>
<h1>前言</h1>
<p>对于一个小白来说，第一次建立自己的个人网页还真是一件既兴奋又无奈的事情。兴奋是因为你即将有一个属于自己的平台，可以将自己的感悟、收藏、简历等文章保存起来，也可以分享给他人。无奈是因为，在你搭着搭着，你会发现出现了各种各样的问题，这其中包含你的一些个性却没法实现的需求以及半路杀出的各种bug。不过，经历一番麻烦，也是会留下深刻的印象的。</p>
<h1>需求</h1>
<p>说到建立网站，不得不考虑不同人出于不同的需求，来走自己的网站路线。可是，对于小白们或者不干网站这方面的大佬们来说，做一个又显得费劲。而我想我的需求跟大部分人一样，当然我的实现也是比较low的一种。我没有买域名，也没有租服务器，而是蹭github的*<a href="https://pages.github.com/">github page</a>*，具体创建仓库的教程网上都有详细概述。<br>
而下面的两个配置路线有两个优点</p>
<ol>
<li>有成型的网页模板，会让你的主页逼格瞬间提升一个档次。</li>
<li>方便后续更新维护你的网站。</li>
</ol>
<h1>github page建网页路线</h1>
<ol>
<li>GitHub Pages + Hexo</li>
<li>GitHub Pages + jekyll<br>
我采用的搭建博客的方式是第一种，建议Windows用户走第一种。<br>
因为我先走的第二种，走到一半卡死了，cmd窗口出现毫无头绪的错误，网上也找不到什么解决方案。当然你也可以勇于尝试，毕竟机子不同嘛。<br>
接下来我们先说第一种</li>
</ol>
<h1>Hexo配置</h1>
<h2 id="下载-node-js">下载*<a href="https://nodejs.org/en/">Node.js</a>*</h2>
<p>其中 LTS为稳定版本 ，Current为当前最新版本</p>
<h2 id="下载-git">下载*<a href="https://git-scm.com/">git</a>*</h2>
<p>下载完配置账户，及ssh等，这里有详细介绍*<a href="https://blog.csdn.net/qq_23341529/article/details/79331519">git配置</a>*</p>
<h2 id="安装hexo及初步预览">安装Hexo及初步预览</h2>
<p>网上大多hexo的配置都是以前版本的指令了，最新的还要参考*<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>*<br>
任意位置右键选择Git Bash Here(即打开git的命令窗口)<br>
<code>$ npm install -g hexo-cli</code><br>
接下来找一个你要建立网站的目录，在它的上一级git bash here，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;  </span><br><span class="line">$ cd &lt;folder&gt;  </span><br><span class="line">$ npm install  </span><br></pre></td></tr></table></figure>
<p>此时你的界面应该是这样的</p>
<p><img src="/assets/1547024489695.png" alt="1547024489695"></p>
<p>下面我们测试一下环境搭的怎么样<br>
<code>hexo g</code><br>
原为generate缩写为g，意为生成，在*<a href="https://hexo.io/zh-cn/docs/">hexo官网</a>*上有详细的说明<br>
<code>hexo s</code><br>
原为server缩写为s，提交到本地服务器进行查看<br>
当你看到这个界面</p>
<p><img src="/assets/1547024466501.png" alt="1547024466501"></p>
<p>就说明你测试成功啦，恭喜，就可以到*<a href="http://localhost:4000/">http://localhost:4000/</a>*查看你已经初步搭建的网页预览图啦。<br>
<strong>如果你的目的达成了，那么下面就不需要继续看下去了，想有不同风格的主题往下看。</strong></p>
<h2 id="网站主题">网站主题</h2>
<h3 id="寻找主题">寻找主题</h3>
<p>当我们看到预览图，肯定会有些小兴奋，不过冷静，事情还没办完。<br>
留心查看一下，你会发现根目录下有个themes的文件夹，我们下面自己下载的主题就放到这个目录下面。<br>
现在，到*<a href="https://hexo.io/themes/">hexo主题平台</a>*选择自己喜欢的主题吧，样式非常多，有的挑了。</p>
<h3 id="下载主题">下载主题</h3>
<p>下载主题两种方式.</p>
<ol>
<li>第一种是点开主题的github界面，按照README.txt中的指令，在刚刚提到的themes目录下操作</li>
<li>第二种是github界面右上角下载&quot;clone and download&quot;  下完之后放到themes目录下</li>
</ol>
<h3 id="配置主题">配置主题</h3>
<p>其实不只是配置主题，对Github页面的大部分编辑操作都涉及到根目录下面的_config.yml文件，将其中的themes后面的值改为对应主题文件夹名称。<br>
<strong>注意中间的空格不能丢，会报错的</strong></p>
<h3 id="编辑页面">编辑页面</h3>
<p>之后就根据不同主题的风格进行操作了，主要结合hexo官方文档以及对应主题github下readme.txt的说明来完成。  最好下个*<a href="https://www.sublimetext.com/3">sublime text 3</a>*<br>
编辑文本会非常方便，单纯用txt打开会遇到编码乱码问题，不利于后续文本的编辑<br>
至于编辑，你还得会markdown，所以把东西很多，都得会，不过markdown非常简单，作为程序员你不得不用它，因为它确实很牛，sublime中可以下载markdown编辑插件，详细见教程*<a href="https://www.cnblogs.com/james-lee/p/6847906.html">Sublime Text3 + Markdown + 实时预览</a>*个人觉得这比网页里面预览方便多了。<br>
<strong>注意：所有的操作都在你网站目录下的git bash中完成</strong></p>
<h2 id="提交修改三步走">提交修改三步走</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中hexo d是部署到github上去的，要是没弄好，先前两步多走几次，多预览几下，再提交到github。</p>
<p>github page网站配置分享到此结束，感谢查看。</p>
<h1>参考</h1>
<p><em>整体说明: <a href="https://blog.csdn.net/tianbo_zhang/article/details/79137103">https://blog.csdn.net/tianbo_zhang/article/details/79137103</a></em></p>
<p><em>官方文档: <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></em></p>
<p><em>hexo主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></em></p>
<p><em>hexo_config.yml配置示例：<a href="https://www.cnblogs.com/littlewriter/p/7229094.html">https://www.cnblogs.com/littlewriter/p/7229094.html</a></em></p>
<p><em>markdown基本语法：<a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></em></p>
<p><em>sublime text 3下载地址：<a href="https://www.sublimetext.com/3">https://www.sublimetext.com/3</a></em></p>
<p><em>markdown实时预览：<a href="https://www.cnblogs.com/james-lee/p/6847906.html">https://www.cnblogs.com/james-lee/p/6847906.html</a></em></p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python之wordcloud教程</title>
    <url>/2018/08/07/04Wordcloud/</url>
    <content><![CDATA[<p><img src="/images/wordcloud.jpg" alt="cover"></p>
<a id="more"></a>
<h2 id="wordcloud介绍">wordcloud介绍</h2>
<p>wordcloud是python提供的一个包，主要可以用于数据分析，搭配matplotlib包生成可视化词图，加强我们对数据的理解，便于分析。<br>
<strong>如果你只是想快捷的利用现成的数据来做一张词图，并不打算深入了解python这门语言，那么恭喜你，你将在这里直接利用数据生成你想要的各种词图，非常方便。入口:</strong><a href="http://www.huabandata.com/tools/wordcloud/">词云助手</a></p>
<h2 id="环境说明">环境说明</h2>
<h3 id="python环境">python环境</h3>
<p>首先要有<a href="https://www.python.org/downloads/release/python-370/">python环境</a>，可以直接单击下载python。不过如果是初学者建议下载Anaconda3,Anaconda指的是一个开源的Python发行版本，其中包含了python正常使用需要的大部分包并且能自动配置环境变量，提供jupyter notebook等IDE，非常适合新手。点击查看<a href="https://blog.csdn.net/program_developer/article/details/79677557"><br>
Anaconda详细安装使用教程</a></p>
<h3 id="wordcloud包">wordcloud包</h3>
<p>快捷键win+r打开windows运行窗口(左下角)，输入cmd回车，打开命令窗口.<br>
在命令行中输入<code>pip install wordcloud</code>或者<code>conda install wordcloud</code>，等待安装wordcloud包。</p>
<h2 id="开始编程">开始编程</h2>
<p>首先打开你的jupyter notebook环境，还是通过win+r,输入jupyter notebook，回车。等待几十秒，跳转到页面里，就可以开始使用jupyter了。jupyter的教程网上有很多，这里就不再赘述，只介绍wordcloud的相关使用方法。<br>
需要数据及源码的单击进入<a href="https://pan.baidu.com/s/1dV9u3aSV1flT3F6diTy_tA">百度云</a>，密码: rugu ，进行下载<br>
下面是实现词云的详细代码及注释（#之后为注释内容）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud,STOPWORDS,ImageColorGenerator</span><br><span class="line"> </span><br><span class="line"><span class="comment">#backgroup_Image = plt.imread(&#x27;F:/man.jpg&#x27;) #笼罩图</span></span><br><span class="line"> </span><br><span class="line">f = open(<span class="string">&#x27;F:\人工智能.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read()  <span class="comment">#生成词云的文档</span></span><br><span class="line">wordcloud = WordCloud(</span><br><span class="line">        background_color = <span class="string">&#x27;white&#x27;</span>, <span class="comment">#背景颜色，根据图片背景设置，默认为黑色</span></span><br><span class="line">        <span class="comment">#mask = backgroup_Image, #笼罩图</span></span><br><span class="line">        font_path = <span class="string">&#x27;C:\Windows\Fonts\STZHONGS.TTF&#x27;</span>,<span class="comment">#若有中文需要设置才会显示中文</span></span><br><span class="line">        width = <span class="number">1000</span>,</span><br><span class="line">        height = <span class="number">860</span>,</span><br><span class="line">        margin = <span class="number">2</span>).generate(f) <span class="comment"># generate 可以对全部文本进行自动分词</span></span><br><span class="line"><span class="comment">#参数 width，height，margin分别对应宽度像素，长度像素，边缘空白处</span></span><br><span class="line"> </span><br><span class="line">plt.imshow(wordcloud)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment">#保存图片：默认为此代码保存的路径</span></span><br><span class="line">wordcloud.to_file(<span class="string">&#x27;touxiang.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><em>Anaconda安装教程：<a href="https://blog.csdn.net/program_developer/article/details/79677557">https://blog.csdn.net/program_developer/article/details/79677557</a></em></p>
<p><em>Conda管理python包：<a href="https://blog.csdn.net/dennis_shaw/article/details/77535659">https://blog.csdn.net/dennis_shaw/article/details/77535659</a></em></p>
<p><em>wordcloud词云安装到入门： <a href="https://blog.csdn.net/arise007/article/details/79346169">https://blog.csdn.net/arise007/article/details/79346169</a></em></p>
<p><em>wordcloud词云详教程：<a href="https://www.2cto.com/kf/201712/707704.html">https://www.2cto.com/kf/201712/707704.html</a></em></p>
<p><em>wordcloud词云助手：<a href="http://www.huabandata.com/tools/wordcloud/">http://www.huabandata.com/tools/wordcloud/</a></em></p>
]]></content>
      <categories>
        <category>技术改变生活</category>
      </categories>
      <tags>
        <tag>wordcloud</tag>
      </tags>
  </entry>
</search>
